// sdl/dsl/driver.go
package decl

import (
	"fmt"
	// Need for parseLiteralValue
	// Needed for component constructors & internal funcs
	"github.com/panyam/leetcoach/sdl/core"
)

// RunDSL executes the logic defined in an AST, focusing on System and Analyze blocks.
// Returns a map of analysis names to their corresponding AnalysisResultWrapper.
func RunDSL(vm *VM, astRoot Node /* options? */) (map[string]*AnalysisResultWrapper, error) {
	analysisResults := make(map[string]*AnalysisResultWrapper)

	// --- Basic Setup ---
	system, ok := astRoot.(*System)
	if !ok {
		return analysisResults, fmt.Errorf("RunDSL currently expects *System as root, got %T", astRoot)
	}

	if vm == nil {
		vm = &VM{}
		vm.Init()
	}

	// --- Process System ---
	systemEnv := NewEnclosedEnvironment(vm.env)
	vm.env = systemEnv // Switch to system env for instantiation

	// Instantiate components
	for _, node := range system.Body {
		instance, isInstance := node.(*Instance)
		if !isInstance {
			continue
		}
		// ... (Instantiation logic remains the same) ...
		constructorRaw, typeFound := systemEnv.Get(instance.ComponentType)
		if !typeFound {
			// Store error and continue? Or return immediately? Return for now.
			err := fmt.Errorf("component type '%s' not found for instance '%s'", instance.ComponentType, instance.Name)
			// We don't have a result wrapper yet to store this error in.
			return analysisResults, err
		}
		constructor, isConstructor := constructorRaw.(ComponentConstructor)
		if !isConstructor {
			err := fmt.Errorf("type '%s' is not a constructible component", instance.ComponentType)
			return analysisResults, err
		}
		params := make(map[string]any)
		for _, p := range instance.Params {
			if lit, okLit := p.Value.(*LiteralExpr); okLit {
				parsedVal, err := ParseLiteralValue(lit)
				if err != nil {
					return analysisResults, fmt.Errorf("error parsing param '%s' for instance '%s': %w", p.Name, instance.Name, err)
				}
				params[p.Name] = parsedVal
			} else {
				return analysisResults, fmt.Errorf("parameter '%s' for instance '%s' must be a literal (for now)", p.Name, instance.Name)
			}
		}
		instanceObj, err := constructor(instance.Name, params)
		if err != nil {
			return analysisResults, fmt.Errorf("error constructing instance '%s': %w", instance.Name, err)
		}
		systemEnv.Set(instance.Name, instanceObj)
	} // End instantiation loop

	// Run Analyze blocks
	for _, node := range system.Body {
		analyze, isAnalyze := node.(*Analyze)
		if !isAnalyze {
			continue
		}

		analysisName := analyze.Name
		// Create the result wrapper
		resultWrapper := &AnalysisResultWrapper{
			Name:    analysisName,
			Metrics: make(map[core.MetricType]float64), // Use correct key type
		}
		analysisResults[analysisName] = resultWrapper

		resultWrapper.AddMsg("Starting analysis '%s'...", analysisName)
		vm.ClearStack() // Ensure clean stack

		// Evaluate the target expression
		_, evalErr := vm.Eval(analyze.Target)

		if evalErr != nil {
			resultWrapper.AddMsg("Evaluation error: %v", evalErr)
			resultWrapper.Error = evalErr
			resultWrapper.Skipped = true
			resultWrapper.AnalysisPerformed = false // Mark as not performed due to eval error
			continue
		}

		// Get final outcome from stack
		finalOutcome, stackErr := vm.GetFinalResult()
		if stackErr != nil {
			resultWrapper.AddMsg("Stack error after evaluation: %v", stackErr)
			resultWrapper.Error = stackErr
			resultWrapper.Skipped = true
			resultWrapper.AnalysisPerformed = false // Mark as not performed due to stack error
			continue
		}
		resultWrapper.Outcome = finalOutcome // Store the raw *core.Outcomes[V] object

		// Calculate Metrics
		CalculateAndStoreMetrics(resultWrapper) // Pass the wrapper
		// Log some results for feedback
		if resultWrapper.AnalysisPerformed {
			resultWrapper.AddMsg("Analysis complete. Availability: %.6f, P99: %.6fs",
				resultWrapper.Metrics[core.AvailabilityMetric], resultWrapper.Metrics[core.P99LatencyMetric])
		} else {
			resultWrapper.AddMsg("Analysis finished, but metrics could not be calculated (Outcome type: %T).", resultWrapper.Outcome)
		}

	} // End analyze loop

	vm.env = systemEnv.outer // Restore global env
	return analysisResults, nil
}
