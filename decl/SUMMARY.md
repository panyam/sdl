# SDL Declaration DSL Package Summary (`sdl/decl`)

**Purpose:**

This package implements the high-level System Design Language (DSL) for defining and analyzing system performance models. It aims to provide a declarative interface, abstracting the direct manipulation of probabilistic outcomes defined in `sdl/core`. It defines the language structure (AST), the runtime environment, and the evaluation mechanism that connects the DSL to the underlying `core` and `components` packages.

**Evaluation Strategy: Operator Tree**

The DSL evaluation employs a two-stage strategy using an intermediate "Operator Tree":

1.  **Stage 1: AST Evaluation to Operator Tree (`Eval` function in `eval.go`)**
    *   The `Eval` function walks the Abstract Syntax Tree (AST).  The ast is split into 3 files (intentional):
        * `ast.go` - Defines the top level declarations in a compilation unit (File).   These are loaded and processed
          at parse/load time.  These are not "executable" units like statements and expressions (below) that will be
          evaluated.
        * `stmt.go` and `exprs.go` - Defines statements statements and expressions that are executed at runtime by the
          Evaluators.   These are the units that create results and cause runtime "effects".
    *   It uses the runtime `Frame` (`frame.go`) for lexical scoping and tracking asynchronous futures.
    *   It interacts with the `VM` (`vm.go`) which holds registries for native component constructors and DSL definitions.
    *   It builds an **Operator Tree** (`opnode.go`) representing the computation symbolically.
        *   **Leaves** (`LeafNode`) hold a `VarState` (`state.go`) (Value + Latency outcomes), created from literals or component method calls.
        *   **Internal Nodes** (`SequenceNode`, `BinaryOpNode`, `IfChoiceNode`, `InstanceRefNode` etc.) represent operations and structure.
    *   Component *instantiations* (`InstanceDecl`) are evaluated by calling `vm.CreateInstance`, which handles native vs. DSL creation logic and returns a `ComponentRuntime`.
    *   `ComponentRuntime` instances (`NativeComponent` or `UDComponent`) are stored directly in the `Frame`.
    *   Method calls (`CallExpr`) are evaluated (`evalCall`), resolving the target `ComponentRuntime` and calling its `InvokeMethod`.
        *   Native calls execute Go code via reflection (temporary argument workaround exists).
        *   DSL calls evaluate the method body AST using `Eval` in an isolated frame.
    *   Focuses on building the correct symbolic tree and setting up the runtime environment with component instances. *This stage is partially implemented.*

2.  **Stage 2: Operator Tree Execution (Future "Tree Evaluator")**
    *   *(Not Yet Implemented)* A separate component will process the `OpNode` tree generated by Stage 1.
    *   It will walk the tree, performing actual `VarState` combinations (using the V4 dual-track model defined in `state.go` and combination logic from `reducers.go`).
    *   It will interact with `ComponentRuntime` instances (via `InvokeMethod`) to handle method calls, providing evaluated arguments.
    *   The final result of evaluating an OpNode tree will be a single, combined `VarState`.

**Loading vs. Execution:**

*   **Loading (`vm.LoadFile`):** Parses a `File` AST, processes top-level `component` and `system` definitions, populates the `VM`'s `ComponentDefRegistry` and `SystemDefs` map.
*   **Execution (`vm.ExecuteSystem`):** Takes a system name, retrieves its AST from the VM, creates a root `Frame`, and calls `Eval` on the `SystemDecl` AST to begin Stage 1 evaluation.

**Key Components & Files:**

*   **`ast.go`:** Defines the top level parsed DSL grammar declaration structs (nodes like `FileDecl`, `ComponentDecl`, `SystemDecl`, `InstanceDecl`, `MethodDef`, etc.).
*   **`stmt.go.go` and `exprs.go`:** Defines the parsed DSL grammar structs (nodes like `CallExpr`, `IfStmt`, `DistributeExpr` etc.).
*   **`vm.go`:** `VM` structure, holds registries, `CreateInstance` factory, `LoadFile`, `ExecuteSystem`.
*   **`frame.go`:** `Frame` struct for lexical scope, `locals`, `futures` tracking. `Future` struct.
*   **`eval.go`:** Implements the Stage 1 `Eval` function (builds `OpNode` tree). Handles various AST nodes, calls `vm.CreateInstance`, `evalCall`.
*   **`opnode.go`:** Defines the Operator Tree nodes (`OpNode`, `LeafNode`, `BinaryOpNode`, `IfChoiceNode`, `InstanceRefNode`, etc.).
*   **`state.go`:** Defines `VarState` (dual-track outcomes: `ValueOutcome`, `LatencyOutcome`).
*   **`component.go`:** Defines `ComponentRuntime` interface, `UDComponent` (for DSL components), and `NativeComponent` (for Go components). Implements `InvokeMethod` for both.
*   **`analysis.go`:** Defines `AnalysisResultWrapper`. *(Needs update for `VarState` and Tree Evaluator integration)*.
*   **`reducers.go`:** Manages outcome combination/reduction logic. *(Needs update for `VarState` combination)*.
*   **Design Docs:** `SYNTAX.md`, `GRAMMAR.ebnf`, `FUTURES.md`, `NATIVE.md`, `EXAMPLES.md`.

**Current Status:**

*   AST, Frame, VM, `VarState`, `ComponentRuntime`, and basic `OpNode` types are defined.
*   The Operator Tree evaluation strategy and Load/Execute phases are established.
*   Stage 1 `Eval` handles key structural elements: definitions (processed by `LoadFile`), setup (System execution via `ExecuteSystem`, Instance creation via `vm.CreateInstance`), basic expressions/statements (Literals, Let, Identifiers, Blocks, Binary Ops, If), and method calls (`evalCall`).
*   Method calls work for native components (via adapter+reflection, with argument workaround) and DSL components (body AST is processed by `Eval`, returning an `OpNode`).
*   **Missing:**
    *   The entire Stage 2 "Tree Evaluator" component.
    *   `Eval` logic for remaining ops: `unary`, `distribute`, `delay`, `go`, `wait`, etc.
    *   Updates to `reducers.go` for `VarState` combination logic.
    *   Integration with `analysis.go`.
    *   Removal of temporary workarounds (argument/parameter evaluation via `extractLeafValue`).
