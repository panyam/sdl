
// --- Top Level ---

File = Declaration* EOF ;
Declaration = ComponentDecl | SystemDecl | OptionsDecl | ImportDecl /* Future */ | EnumDecl ;

// Enum Definition - Enums are the way to define outcome "sets"
// We are NOT creating a general purpose language.  This DSL is to aid with performance analysis and capacity planning
// of system designs.  For us more than correctness we want to evaluate the non-functional requirements
EnumDecl = "enum" identifier "{" identifier ("," identifier)* "}" ; // Allows defining named discrete value sets

ImportDecl = "import" StringLiteral ;
OptionsDecl = "options" BlockStmt // Define structure later

// --- Component Definition ---
ComponentDecl = "component" identifier "{" ComponentBodyItem* "}" ;
ComponentBodyItem = ParamDecl | UsesDecl | MethodDef | ComponentDecl ; 

ParamDecl = "param" identifier ":" TypeName ["=" Expression] ";" ;

// *** Refine TypeName ***
TypeName = PrimitiveType | OutcomeType | identifier /* For registered Enums */ ;
PrimitiveType = "int" | "float" | "string" | "bool" | "duration" ;
OutcomeType = "Outcome" "[" PrimitiveType "]" ;

UsesDecl = "uses" identifier ":" identifier ["{" Assignment* "}"] ";" ;

// *** Refine MethodDef ***
MethodDef = "method" identifier "(" [ParamList] ")" [":" TypeName] BlockStmt ;
ParamList = ParamDecl ("," ParamDecl)* ;

// --- System Definition ---
SystemDecl = "system" identifier "{" SystemBodyItem* "}" ;
SystemBodyItem = InstanceDecl
                | AnalyzeDecl
                | OptionsDecl 
                | LetStmt /* Allow system-level constants? */
                ;

InstanceDecl = identifier ":" identifier ["=" "{" Assignment* "}"] ";" ;

// *** Refine AnalyzeDecl ***
AnalyzeDecl = "analyze" identifier "=" Expression [ExpectBlock] ";" ; // analysisName = instance.Method(args)
ExpectBlock = "expect" "{" ExpectStmt* "}" ; // Use braces for clarity
ExpectStmt = Expression Operator Expression ";" ; // TargetExpr Op ThresholdExpr (e.g., target.P99 < 100ms)


// --- Statements ---

Stmt = LetStmt
      | ExprStmt | ReturnStmt | IfStmt
      | DistributeStmt | WaitStmt | DelayStmt
      | GoStmt | LogStmt | BlockStmt
      | SwitchStmt
      /* FilterStmt? */
      ;

// We *could* have an AssignmentStmt but using a let allows us simplicity and flexibility at the same time
LetStmt = identifier ":=" Expression ";" 
          | identifer ":=" "go" Expression ";"      // Let statements can also be futures - they have to be waited on
          ;

// Assignment is for overriding values instead of new values
AssginmentStmt = identifier "=" Expression ";" ;

ExprStmt = Expression ";" ;
ReturnStmt = "return" Expression ";" ;
DelayStmt = "delay" Expression ";" ; // Expr must yield Duration outcome
WaitStmt = "wait" Expression ( "," Expression ) * ";" ; // Wait on one or more futures
LogStmt = "log" (StringLiteral | Expression) ("," Expression)* ";" ;


// --- Control Flow Statements ---
IfStmt = "if" Expression BlockStmt ["else" (IfStmt | BlockStmt)] ; // Condition must yield bool outcome

// - Distribute frankly can never be a statement?
// This can be achieved by a switch?
DistributeStmt = "distribute" [TotalClause] "{" DistributeCase* [DefaultCase] "}" ;
TotalClause = "(" Expression ")" ; // Expr must yield a number outcome with which a distributio will be created
DistributeCase = Expression "=>" BlockStmt ; // Expr must yield float outcome
DefaultCase = "default" "=>" BlockStmt ;

RepeatStmt = "repeat" "(" Expression "," ExecutionMode ")" BlockStmt ; // Expr must yield int outcome
ExecutionMode = identifier{"Sequential"} | identifier{"Go"} ; // Treat as identifiers for now

GoStmt = "go" (identifer "=") BlockStmt 
      | go identifier "=" Expression        // Use for single expression calls instead of entire statements
      ;

// --- Expressions ---
Expression = OrExpr ; // Precedence: || lowest -> && -> Cmp -> Add/Sub -> Mul/Div -> Unary -> Primary

OrExpr      = AndBoolExpr ( "||" AndBoolExpr )* ;
AndBoolExpr = CmpExpr ( "&&" CmpExpr )* ;
CmpExpr     = AddExpr [ ( "==" | "!=" | "<" | "<=" | ">" | ">=" ) AddExpr ] ;
AddExpr     = MulExpr ( ( "+" | "-" ) MulExpr )* ;
MulExpr     = UnaryExpr ( ( "*" | "/" | "%" ) UnaryExpr )* ;
UnaryExpr   = ( "!" | "-" ) UnaryExpr | PrimaryExpr ;

PrimaryExpr = LiteralExpr
            | IdentifierExpr
            | MemberAccessExpr // instance.param or self.param ONLY
            | CallExpr         // func(args) or instance.method(args)
            | DistributeExpr   // Keep separate from DistributeStmt for now
            | "(" Expression ")" ;

DistributeExpr = "distribute" 
DistributeExpr = "distribute" [TotalClause] "{" DistributeExprCase* [DefaultCase] "}" ;
DistributeExprCase = Expression "=>" Expression ; // Expr must yield float outcome
DefaultCaseExpr = "default" "=>" Expression ;

// --- Expression Details ---
LiteralExpr = IntLiteral | FloatLiteral | StringLiteral | BoolLiteral | DurationLiteral ;
DurationLiteral = IntLiteral ("ns" | "us" | "ms" | "s") ; // Allow units

IdentifierExpr = identifier ;

// *** Refine MemberAccessExpr ***
MemberAccessExpr = PrimaryExpr "." identifier ; // Can only access params/fields, not .Success etc.

CallExpr = PrimaryExpr "(" [ArgList] ")" ;
ArgList = Expression ("," Expression)* ;

InternalCallExpr = "Internal" "." identifier "(" [ArgList] ")" ;

// --- Lexical Elements (Simplified) ---
// identifier = letter (letter | digit | "_")* ;
// IntLiteral = digit+ ;
// FloatLiteral = digit+ "." digit+ ;
// StringLiteral = '"' .* '"' ; // Allow escape sequences
// BoolLiteral = "true" | "false" ;
// Comments = "//" ... | "/*" ... "*/" ; (Ignored)
