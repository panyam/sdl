
import StdKVStore from "std_native.sdl" // Assuming this path
import OpStatus from "./common.sdl"

// --- User Storage ---
// Stores user profiles and follow relationships.
component UserStore {
  uses userProfileDB StdKVStore (DiskProfile = "SSD")    // UserID -> UserProfileJSON
  uses followersDB StdKVStore (DiskProfile = "SSD")     // UserID -> List[UserID of followers]
  uses followingDB StdKVStore (DiskProfile = "SSD")     // UserID -> List[UserID of users they follow]

  method CreateUserProfile(userID String, profileData String) OpStatus {
    delay 5ms // Simulate DB write
    if self.userProfileDB.Put(userID, profileData) {
      return OpStatus.SUCCESS
    }
    return OpStatus.FAILURE
  }

  method GetUserProfile(userID String) String { // Returns profileData or empty
    delay 3ms
    return self.userProfileDB.Get(userID)
  }

  method AddFollow(followerID String, followeeID String) OpStatus {
    delay 10ms // Simulate writes to two lists
    let followersUpdated = self.followersDB.AppendToList("followers_of_" + followeeID, followerID)
    let followingUpdated = self.followingDB.AppendToList("following_by_" + followerID, followeeID)
    if followersUpdated && followingUpdated {
      return OpStatus.SUCCESS
    }
    // TODO: Add rollback/compensation logic for partial failure (out of MVP scope)
    return OpStatus.FAILURE
  }

  method RemoveFollow(followerID String, followeeID String) OpStatus {
    delay 10ms
    let followersUpdated = self.followersDB.RemoveFromList("followers_of_" + followeeID, followerID)
    let followingUpdated = self.followingDB.RemoveFromList("following_by_" + followerID, followeeID)
    if followersUpdated && followingUpdated {
      return OpStatus.SUCCESS
    }
    return OpStatus.FAILURE
  }

  method GetFollowing(userID String) List[String] { // List of UserIDs
    delay 5ms
    return self.followingDB.GetList("following_by_" + userID)
  }
}

// --- Tweet Storage ---
// Stores tweets and a reverse chronological list of tweet IDs per user.
component TweetStore {
  uses tweetsDB StdKVStore (DiskProfile = "SSD")         // TweetID -> TweetDataJSON
  uses userTweetsDB StdKVStore (DiskProfile = "SSD")   // UserID -> List[TweetID] (user's own tweets)

  param MaxUserTweetsForTimeline Int = 200 // Max tweets to fetch per user for timeline construction

  method SaveTweet(tweetID String, userID String, tweetData String) OpStatus {
    delay 7ms // Tweet content write
    let tweetSaved = self.tweetsDB.Put(tweetID, tweetData)

    delay 3ms // Index update (user's tweet list)
    // For simplicity, prepending to list. Real DBs have better ways.
    // This simulates adding to a reverse chronological list.
    let userTweetListKey = "tweets_by_" + userID
    let currentTweets = self.userTweetsDB.GetList(userTweetListKey)
    // This is pseudo-code for list manipulation; SDL needs list functions.
    // let newTweets = Prepend(tweetID, currentTweets) // Assumed operation
    // let listUpdated = self.userTweetsDB.PutList(userTweetListKey, newTweets)
    let listUpdated = self.userTweetsDB.AppendToList(userTweetListKey, tweetID) // Simplified: append, assume sorted by time later

    if tweetSaved && listUpdated {
      return OpStatus.SUCCESS
    }
    return OpStatus.FAILURE
  }

  method GetTweet(tweetID String) String { // Returns TweetDataJSON or empty
    delay 2ms
    return self.tweetsDB.Get(tweetID)
  }

  // Gets a list of TweetIDs posted by a user, most recent first (conceptual)
  method GetUserTweets(userID String, count Int, offset Int) List[String] {
    delay 4ms
    // NativeDB.GetListRange would ideally support reverse order or we fetch more and sort.
    // For MVP, assume GetListRange fetches latest if store is append-only for TweetIDs.
    return self.userTweetsDB.GetListRange("tweets_by_" + userID, offset, count)
  }
}
