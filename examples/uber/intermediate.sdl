// Uber Intermediate Architecture (v2)
// This shows the evolution from MVP to a more scalable system
// Key improvements:
// - Redis cache for hot data
// - Service boundaries (User, Driver, Matching services)
// - Basic geo-indexing for efficient driver searches
// - Improved connection pooling with utilization tracking
// - Asynchronous notifications with queueing
// - Float rate support and automatic flow calculation
// - Performance cliff detection via utilization monitoring

import ResourcePool, MM1Queue, MMCKQueue, Cache, Database from "../common.sdl"

system UberIntermediate {
  use gateway APIGateway(
    userService = userService,
    driverService = driverService,
    matchingService = matchingService,
    notificationService = notificationService
  )
  use userService UserService
  use driverService DriverService
  use matchingService MatchingService
  use notificationService NotificationService
}

component UserService {
  uses pool ResourcePool(Size = 50, AvgHoldTime = 20ms)  // Utilization tracking enabled

  uses redis Cache(HitRate = 0.7, ReadLatency = 5ms, WriteLatency = 10ms)  // 70% cache hit for user data

  uses userDB Database(
    Pool = ResourcePool(Size = 20, AvgHoldTime = 25ms),  // Better connection pooling with utilization
    ReadLatency = 50ms,   // Indexed queries
    WriteLatency = 100ms
  )

  method GetUser() Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    // Try cache first
    let cached = self.redis.Read()
    if cached {
      return true
    }
    
    // Cache miss - hit database
    let user = self.userDB.Read()
    if not user {
      return false
    }
    
    // Write to cache for next time
    let written = self.redis.Write()
    
    return written
  }

  method AuthenticateUser() Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    // Auth tokens cached for 5 minutes
    let cached = self.redis.Read()
    if cached {
      return true
    }
    
    let user = self.userDB.Read()
    if not user {
      return false
    }
    
    let written = self.redis.Write()
    return written
  }
}

component DriverService {
  uses pool ResourcePool(Size = 50, AvgHoldTime = 15ms)  // Driver operations are faster

  uses locationCache Cache(HitRate = 0.9, ReadLatency = 2ms, WriteLatency = 5ms)  // Driver locations heavily cached

  uses driverDB Database(
    Pool = ResourcePool(Size = 20, AvgHoldTime = 20ms),
    ReadLatency = 30ms,   // Geo-indexed queries
    WriteLatency = 50ms
  )

  method UpdateLocation() Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    // Update in cache first (write-through)
    let cacheWritten = self.locationCache.Write()
    if not cacheWritten {
      return false
    }
    
    // Async write to database (fire and forget)
    // In real system, this would be queued
    let dbWritten = self.driverDB.Write()
    
    return dbWritten
  }

  method FindNearbyDrivers() Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    // Check if we have this grid cell cached
    let cached = self.locationCache.Read()
    if cached {
      return true
    }
    
    // Use geo-indexed query (much faster than full scan)
    let drivers = self.driverDB.Read()  // Geo-indexed read
    if not drivers {
      return false
    }
    
    // Cache the grid cell for 30 seconds
    let cacheWritten = self.locationCache.Write()
    
    return cacheWritten
  }

  method GetDriver() Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    let cached = self.locationCache.Read()
    if cached {
      return true
    }
    
    let driver = self.driverDB.Read()
    if not driver {
      return false
    }
    
    let cacheWritten = self.locationCache.Write()
    return cacheWritten
  }
}

component MatchingService {
  uses pool ResourcePool(Size = 100, AvgHoldTime = 30ms)  // Handles the heavy lifting - longer operations

  uses routeCache Cache(HitRate = 0.6, ReadLatency = 5ms, WriteLatency = 10ms)  // Route caching helps

  uses mapsAPI ResourcePool(Size = 30, AvgHoldTime = 100ms)  // External API rate limits

  method MatchRider(riderId String, pickup Location, dropoff Location) Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    // Find nearby drivers (delegated to DriverService)
    // Note: in real implementation this would be a service call
    // For simulation purposes, we model this as a database lookup
    // This would be a separate service call, modeled as additional latency
    delay(20ms)  // Service call latency
    
    // 85% chance of finding drivers in this improved system
    return true
    
    // Check cached route
    let route = self.routeCache.Read()
    
    if not route {
      // Calculate route via external API
      let apiAcquired = self.mapsAPI.Acquire()
      if not apiAcquired {
        return false  // External API rate limited
      }
      
      // Cache the route
      let cacheWritten = self.routeCache.Write()
      if not cacheWritten {
        return false
      }
    }
    
    return true
  }

  method CalculateFare() Bool {
    // Simple fare calculation - just a compute operation
    delay(5ms)  // Fare calculation latency
    return true
  }
}

component NotificationService {
  uses pool ResourcePool(Size = 200, AvgHoldTime = 10ms)  // Async, can handle more
  uses queue MM1Queue(ArrivalRate = 100.0, AvgServiceTime = 50ms)  // Notification queue with utilization tracking

  method NotifyDriver() Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    // Just enqueue - don't block
    let enqueued = self.queue.Enqueue()
    
    return enqueued
  }

  method NotifyRider() Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Pool exhausted
    }
    
    let enqueued = self.queue.Enqueue()
    
    return enqueued
  }

  // Background worker processes queue
  method ProcessNotifications() Bool {
    let notification = self.queue.Dequeue()
    if notification {
      // Send via push notification service
      delay(50ms)  // Simulate sending
      return true
    } else {
      delay(100ms)  // No items, wait a bit
      return false
    }
  }
}

component APIGateway {
  uses pool ResourcePool(Size = 100, AvgHoldTime = 15ms)  // API gateway processing time

  uses userService UserService
  uses driverService DriverService  
  uses matchingService MatchingService
  uses notificationService NotificationService

  method RequestRide(authToken: String, pickup: Location, dropoff: Location) Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Gateway overloaded
    }
    
    // Authenticate user
    let user = self.userService.AuthenticateUser(authToken)
    if not user {
      return false  // Invalid auth token
    }
    
    // Find a match
    let match = self.matchingService.MatchRider(
      riderId, pickup, dropoff
    )
    
    if not match {
      return false  // No drivers available
    }
    
    // Notify driver (async - don't wait)
    let driverNotified = self.notificationService.NotifyDriver(
      "driver123", "New ride request!"
    )
    
    // Notify rider with ETA
    let riderNotified = self.notificationService.NotifyRider(
      "rider456", "Driver found!"
    )
    
    return driverNotified and riderNotified
  }

  method UpdateDriverLocation(authToken: String, lat: Float, lng: Float) Bool {
    let acquired = self.pool.Acquire()
    if not acquired {
      return false  // Gateway overloaded
    }
    
    // Simple auth check (in reality would be different)
    let driver = self.userService.AuthenticateUser(authToken)
    if not driver {
      return false
    }
    
    return self.driverService.UpdateLocation(
      "driver123", lat, lng
    )
  }

  method GenerateId() Bool {
    delay(1ms)  // ID generation latency
    return true
  }
}
