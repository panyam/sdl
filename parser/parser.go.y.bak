%{
package parser

import (
    "fmt"
    "strconv"
    "strings"
    "bufio"
    "io"
    "os" // Used only in main() for example
)

// Result holds the final parsed AST File node.
// It's populated by the top-level rule's semantic action.
var parseResult *File

// Helper to combine position info - assumes lexer provides positions.
// We'll need to make the lexer accessible, e.g., via yyParseWithLexer.
func newNodeInfo(startPos, endPos int) NodeInfo {
    return NodeInfo{StartPos: startPos, StopPos: endPos}
}

// Helper function to create a LiteralExpr node
func newLiteralExpr(kind, value string, startPos, endPos int) *LiteralExpr {
	// For string literals, the lexer should provide the raw unquoted value.
	return &LiteralExpr{
		NodeInfo: newNodeInfo(startPos, endPos),
		Kind:     kind,
		Value:    value,
	}
}

// Helper function to create an IdentifierExpr node
func newIdentifierExpr(name string, startPos, endPos int) *IdentifierExpr {
	return &IdentifierExpr{
		NodeInfo: newNodeInfo(startPos, endPos),
		Name:     name,
	}
}

// Function to be called by yyParse on error.
// Needs access to the lexer passed via %parse-param.
func yyerror(lexer SdlLexer, msg string) {
    // Use lexer methods to get position and text
    lexer.Error(fmt.Sprintf("%s near '%s'", msg, lexer.Text()))
}

%}

// Add %parse-param to accept the lexer instance

%union {
    // Basic types from lexer
    sval string // Holds raw string values like identifiers, literal content

    // AST Nodes (using pointers)
    file        *File
    componentDecl *ComponentDecl
    systemDecl *SystemDecl
    node        Node // Generic interface for lists
    expr        Expr
    stmt        Stmt
    typeName    *TypeName
    paramDecl   *ParamDecl
    usesDecl    *UsesDecl
    methodDef   *MethodDef
    instanceDecl *InstanceDecl
    analyzeDecl *Analyze
    expectBlock *ExpectBlock
    expectStmt  *ExpectStmt
    blockStmt   *BlockStmt
    ifStmt      *IfStmt
    distributeStmt *DistributeStmt
    distributeCase *DistributeCase
    defaultCase    *DefaultCase
    goStmt         *GoStmt
    assignStmt     *AssignmentStmt
    optionsDecl    *Options
    enumDecl       *Enum
    importDecl     *Import

    // Slices for lists
    nodeList           []Node
    compBodyItemList   []ComponentDeclBodyItem
    sysBodyItemList    []SystemDeclBodyItem
    paramList          []*ParamDecl
    assignList         []*AssignmentStmt
    exprList           []Expr
    stmtList           []Stmt
    identList          []*IdentifierExpr
    distributeCaseList []*DistributeCase
    expectStmtList     []*ExpectStmt
}

// --- Tokens ---

// Keywords
%token COMPONENT SYSTEM PARAM USES METHOD INSTANCE ANALYZE EXPECT LET IF ELSE DISTRIBUTE DEFAULT RETURN DELAY WAIT GO LOG SWITCH CASE ENUM IMPORT OPTIONS TRUE FALSE FOR INT FLOAT BOOL STRING DURATION // Added FOR

// Literals (lexer provides the actual *LiteralExpr node in lval.expr)
%token <expr> IDENTIFIER INT_LITERAL FLOAT_LITERAL STRING_LITERAL BOOL_LITERAL DURATION_LITERAL

// Operators and Punctuation
%token ASSIGN /* = */ COLON SEMICOLON LBRACE RBRACE LPAREN RPAREN COMMA DOT ARROW /* => */ PLUS_ASSIGN MINUS_ASSIGN MUL_ASSIGN DIV_ASSIGN LET_ASSIGN /* := */

// Operators (Tokens for precedence rules)
%token <sval> OR AND EQ NEQ LT LTE GT GTE PLUS MINUS MUL DIV MOD NOT

// --- Types (Associating non-terminals with union fields) ---
%type <file>         File
%type <nodeList>     DeclarationList TopLevelDeclaration
%type <node>         ComponentBodyItem SystemBodyItem 
%type <componentDecl>         ComponentDecl
%type <systemDecl>         SystemDecl
%type <compBodyItemList> ComponentBodyItemList ComponentBodyItemOptList
%type <sysBodyItemList>  SystemBodyItemOptList
%type <optionsDecl>  OptionsDecl
%type <enumDecl>     EnumDecl
%type <identList>    IdentifierList CommaIdentifierListOpt
%type <importDecl>   ImportDecl
%type <stmt>         Stmt IfStmtElseOpt LetStmt ExprStmt ReturnStmt DelayStmt WaitStmt LogStmt SwitchStmt AssignStmt // Added AssignStmt
%type <blockStmt>         BlockStmt
%type <stmtList>     StmtList StmtOptList
%type <expr>         Expression OrExpr AndBoolExpr CmpExpr AddExpr MulExpr UnaryExpr PrimaryExpr LiteralExpr CallExpr MemberAccessExpr SwitchExpr CaseExpr DefaultCaseExpr // Added SwitchExpr, CaseExpr, DefaultCaseExpr
%type <exprList>     ArgList ArgListOpt CommaExpressionListOpt
%type <paramDecl>    ParamDecl
%type <paramList>    ParamList ParamListOpt 
%type <typeName>     TypeName PrimitiveType // FUTURE USE: OutcomeType QualifiedIdentifier
%type <usesDecl>     UsesDecl AssignListOpt
%type <methodDef>    MethodDef
%type <instanceDecl> InstanceDecl
%type <assignStmt>   Assignment
%type <assignList>   AssignList 
%type <analyzeDecl>  AnalyzeDecl ExpectBlockOpt
%type <expectBlock>  ExpectBlock
%type <expectStmt>   ExpectStmt
%type <expectStmtList> ExpectStmtList ExpectStmtOptList
%type <ifStmt>       IfStmt
%type <distributeStmt> DistributeStmt TotalClauseOpt DistributeCaseListOpt DefaultCaseOpt
%type <distributeCase> DistributeCase
%type <defaultCase>    DefaultCase
%type <distributeExpr> DistributeExpr DistributeExprCaseListOpt DefaultCaseExprOpt
%type <expr>           DistributeExprCase DefaultCaseExpr // Expr for cases
%type <goStmt>         GoStmt

// --- Operator Precedence and Associativity (Lowest to Highest) ---
%left OR
%left AND
%nonassoc EQ NEQ LT LTE GT GTE // Comparisons don't chain
%left PLUS MINUS
%left MUL DIV MOD
%right NOT UMINUS // Unary operators (UMINUS for precedence)

%%
// --- Grammar Rules ---

File:
    DeclarationList {
      // $$ = &File{declarations: $1}; parseResult = $$
      // Assign the result to the implicitly passed pointer
      // 'yylex.(*yyLex).result' is a common pattern if %parse-param works easily,
      // otherwise we might need a slightly different mechanism.
      // Let's try a simpler assignment first, assuming yacc handles return.
      // The generated yyParse might return int, needing result storage in lexer.
      // **Alternative:** Store result in the lexer instance passed via param.
      lexer.(*Lexer).parseResult = &File{declarations: $1} // Store in lexer
    } 
    ;

DeclarationList:
    /* empty */         { $$ = []Node{} }
    | DeclarationList TopLevelDeclaration { $$ = append($1, $2.(Node)) }
    ;

// Allow LetStmt at top level? Maybe not standard, keep separate for now.
TopLevelDeclaration:
      ComponentDecl { $$ = $1 }
    | SystemDecl    { $$ = $1 }
    | OptionsDecl   { $$ = $1 }
    | EnumDecl      { $$ = $1 }
    | ImportDecl    { $$ = $1 }
    ;

OptionsDecl:
    OPTIONS LBRACE StmtList RBRACE {
        $$ = &Options{
            NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(4)), // Pos of OPTIONS, Pos of RBRACE
            Body: &BlockStmt{
                 NodeInfo: newNodeInfo(lexer.PosAt(2), lexer.PosAt(4)), // Pos of LBRACE, Pos of RBRACE
                 Statements: $3,
             },
         }
    }
    ;

EnumDecl:
    ENUM IDENTIFIER LBRACE IdentifierList RBRACE {
        $$ = &Enum{
            NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(5)), // Pos of ENUM, Pos of RBRACE
            Name: $2.(*IdentifierExpr),
            Values: $4,
        }
    }
    ;

IdentifierList:
    IDENTIFIER                { $$ = []*IdentifierExpr{$1.(*IdentifierExpr)} }
    | IdentifierList COMMA IDENTIFIER { $$ = append($1, $3.(*IdentifierExpr)) }
    ;

ImportDecl:
    IMPORT STRING_LITERAL {
        // Assuming STRING_LITERAL token ($2) already has position from lexer
        $$ = &Import{
            NodeInfo: newNodeInfo(lexer.PosAt(1), $2.(Node).End()), // Pos of IMPORT, End of literal
            Path: $2.(*LiteralExpr),
        }
    }
    ;

// --- Component ---
ComponentDecl:
    COMPONENT IDENTIFIER LBRACE ComponentBodyItemList RBRACE {
        $$ = &ComponentDecl{
            NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(5)), // Pos of COMPONENT, Pos of RBRACE
            Name: $2.(*IdentifierExpr),
            Body: $4,
         }
    }
    ;

ComponentBodyItemList: ComponentBodyItemOptList { $$ = $1 } ;

ComponentBodyItemOptList: /* empty */ { $$=[]ComponentDeclBodyItem{} } | ComponentBodyItemOptList ComponentBodyItem { $$=append($1, $2.(ComponentDeclBodyItem)) };

ComponentBodyItem:
      ParamDecl   { $$ = $1 }
    | UsesDecl    { $$ = $1 }
    | MethodDef   { $$ = $1 }
    | ComponentDecl { $$ = $1 } // Allow nested components
    ;

ParamDecl:
    PARAM IDENTIFIER COLON TypeName SEMICOLON {
        $$ = &ParamDecl{
            NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(5)), // Pos of PARAM, Pos of SEMICOLON
            Name: $2.(*IdentifierExpr),
            Type: $4,
        }
    }
    | PARAM IDENTIFIER COLON TypeName ASSIGN Expression SEMICOLON {
        $$ = &ParamDecl{
            NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(7)), // Pos of PARAM, Pos of SEMICOLON
            Name: $2.(*IdentifierExpr),
            Type: $4,
            DefaultValue: $6,
        }
    }
    ;

TypeName:
      PrimitiveType { $$ = $1 }
    | IDENTIFIER    {
                      identNode := $1.(Node)
                      $$ = &TypeName{
                           NodeInfo: identNode.(*IdentifierExpr).NodeInfo, // Use position from IDENTIFIER token
                           EnumTypeName: identNode.(*IdentifierExpr).Name,
                      }
                    }
    // | QualifiedIdentifier { $$ = $1 } // For future pkg.Type
    // | OutcomeType { $$ = $1 } // Need separate rule if we allow Outcome[T] syntax
    ;

PrimitiveType:
      INT      { $$ = &TypeName{NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.EndAt(1)), PrimitiveTypeName: "int"} }
    | FLOAT    { $$ = &TypeName{NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.EndAt(1)), PrimitiveTypeName: "float"} }
    | STRING   { $$ = &TypeName{NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.EndAt(1)), PrimitiveTypeName: "string"} }
    | BOOL     { $$ = &TypeName{NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.EndAt(1)), PrimitiveTypeName: "bool"} }
    | DURATION { $$ = &TypeName{NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.EndAt(1)), PrimitiveTypeName: "duration"} }
    ;

// Placeholder for future pkg.Type or Outcome[T]
// QualifiedIdentifier: IDENTIFIER DOT IDENTIFIER { ... }
// OutcomeType: "Outcome" LBRACKET PrimitiveType RBRACKET { ... }

UsesDecl:
    USES IDENTIFIER COLON IDENTIFIER SEMICOLON {
        $$ = &UsesDecl{
            NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(5)), // Pos of USES, Pos of SEMICOLON
            Name: $2.(*IdentifierExpr),
            ComponentType: $4.(*IdentifierExpr),
         }
    }
    // Optional: Add syntax for overrides within uses? Like `uses x: T { p1 = v1; }`
    // USES IDENTIFIER COLON IDENTIFIER LBRACE AssignListOpt RBRACE SEMICOLON { ... }
    ;

MethodDef:
    METHOD IDENTIFIER LPAREN ParamListOpt RPAREN BlockStmt {
        $$ = &MethodDef{
            NodeInfo: newNodeInfo(lexer.PosAt(1), $6.(Node).End()), // Pos of METHOD, End of BlockStmt
            Name: $2.(*IdentifierExpr),
            Parameters: $4,
            Body: $6,
        }
    }
    | METHOD IDENTIFIER LPAREN ParamListOpt RPAREN COLON TypeName BlockStmt {
        $$ = &MethodDef{
            NodeInfo: newNodeInfo(lexer.PosAt(1), $8.(Node).End()), // Pos of METHOD, End of BlockStmt
            Name: $2.(*IdentifierExpr),
            Parameters: $4,
            ReturnType: $7,
            Body: $8,
         }
    }
    ;

ParamListOpt:
    /* empty */ { $$ = []*ParamDecl{} }
    | ParamList { $$ = $1 }
    ;

ParamList:
    ParamDecl               { $$ = []*ParamDecl{$1} }
    | ParamList COMMA ParamDecl { $$ = append($1, $3) }
    ;

// --- System ---
SystemDecl:
    SYSTEM IDENTIFIER LBRACE SystemBodyItemOptList RBRACE {
        $$ = &SystemDecl{
             NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(5)), // Pos of SYSTEM, Pos of RBRACE
             Name: $2.(*IdentifierExpr),
             Body: $4,
        }
    }
    ;

// SystemBodyItemOptList don't create top-level NodeInfo nodes
SystemBodyItem:
              InstanceDecl { $$=$1 }
            | AnalyzeDecl { $$=$1 }
            | OptionsDecl { $$=$1 }
            | LetStmt { $$=$1 }
            ;

SystemBodyItemOptList:
    /* empty */             { $$ = []SystemDeclBodyItem{} }
    | SystemBodyItemOptList SystemBodyItem { $$ = append($1, $2.(SystemDeclBodyItem)) }
    ;

InstanceDecl:
    IDENTIFIER COLON IDENTIFIER SEMICOLON {
         $$ = &InstanceDecl{
             NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), // Pos of IDENTIFIER, Pos of SEMICOLON
             Name: $1.(*IdentifierExpr),
             ComponentType: $3.(*IdentifierExpr),
             Overrides: []*AssignmentStmt{},
         }
    }
    | IDENTIFIER COLON IDENTIFIER ASSIGN LBRACE AssignListOpt RBRACE SEMICOLON {
        $$ = &InstanceDecl{
             NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(8)), // Pos of IDENTIFIER, Pos of SEMICOLON
             Name: $1.(*IdentifierExpr),
             ComponentType: $3.(*IdentifierExpr),
             Overrides: $6,
         }
    }
    ;

AssignListOpt:
      /* empty */  { $$ = []*AssignmentStmt{} }
    | AssignList { $$ = $1 }
    ;

AssignList:
    Assignment             { $$ = []*AssignmentStmt{$1} }
    | AssignList Assignment { $$ = append($1, $2) }
    ;

Assignment:
    IDENTIFIER ASSIGN Expression SEMICOLON {
        $$ = &AssignmentStmt{
            NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), // Pos of IDENTIFIER, Pos of SEMICOLON
            Var: $1.(*IdentifierExpr),
            Value: $3,
         }
    }
    ;

AnalyzeDecl:
    ANALYZE IDENTIFIER ASSIGN Expression ExpectBlockOpt SEMICOLON {
        // Ensure Expression is CallExpr? Parser might allow any Expr. Check in Eval later.
        callExpr, ok := $4.(*CallExpr)
        if !ok {
            yyerror(lexer, fmt.Sprintf("analyze target must be a method call, found %T", $4))
        }
        endPos := lexer.PosAt(6)
        if $5 != nil { endPos = $5.(Node).End() } // End at ExpectBlock if present
        $$ = &Analyze{
             NodeInfo: newNodeInfo(lexer.PosAt(1), endPos), // Pos of ANALYZE, End of Expr/Block
             Name: $2.(*IdentifierExpr),
             Target: callExpr,
             Expectations: $5,
         }
    }
    ;

ExpectBlockOpt: /* empty */   { $$ = nil } | ExpectBlock { $$ = $1 };

ExpectBlock:
    EXPECT LBRACE ExpectStmtList RBRACE {
        $$ = &ExpectBlock{
            NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(4)), // Pos of EXPECT, Pos of RBRACE
            Expects: $3,
        }
    }
    ;

ExpectStmtList:
      ExpectStmtOptList { $$ = $1 }
    ;

ExpectStmtOptList:
      /* empty */            { $$ = []*ExpectStmt{} }
    | ExpectStmtOptList ExpectStmt { $$ = append($1, $2) }
    ;

ExpectStmt:
    Expression EQ Expression SEMICOLON  { $$ = &ExpectStmt{ NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), Target: $1.(*MemberAccessExpr), Operator: "==", Threshold: $3} }
    | Expression NEQ Expression SEMICOLON { $$ = &ExpectStmt{ NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), Target: $1.(*MemberAccessExpr), Operator: "!=", Threshold: $3} }
    | Expression LT Expression SEMICOLON  { $$ = &ExpectStmt{ NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), Target: $1.(*MemberAccessExpr), Operator: "<", Threshold: $3} }
    | Expression LTE Expression SEMICOLON { $$ = &ExpectStmt{ NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), Target: $1.(*MemberAccessExpr), Operator: "<=", Threshold: $3} }
    | Expression GT Expression SEMICOLON  { $$ = &ExpectStmt{ NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), Target: $1.(*MemberAccessExpr), Operator: ">", Threshold: $3} }
    | Expression GTE Expression SEMICOLON { $$ = &ExpectStmt{ NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)), Target: $1.(*MemberAccessExpr), Operator: ">=", Threshold: $3} }
    ;

// --- Statements ---
StmtList: StmtOptList { $$ = $1 } ;
StmtOptList: /* empty */       { $$ = []Stmt{} } | StmtOptList Stmt { $$ = append($1, $2) } ;

Stmt:
      LetStmt        { $$ = $1 }
    | ExprStmt       { $$ = $1 }
    | ReturnStmt     { $$ = $1 }
    | IfStmt         { $$ = $1 }
    | WaitStmt       { $$ = $1 }
    | DelayStmt      { $$ = $1 }
    | GoStmt         { $$ = $1 }
    | LogStmt        { $$ = $1 }
    | BlockStmt      { $$ = $1 }
    // | DistributeStmt { $$ = $1 }
    | SwitchStmt     { $$ = $1 } // Add SwitchStmt
    // | AssignStmt     { $$ = $1 } // Allow assignments as statements? Let's require `let` for now.
    | error SEMICOLON { yyerrok() /* Recover on semicolon */ } // Basic error recovery
    ;


BlockStmt:
    LBRACE StmtList RBRACE { $$ = &BlockStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(3)), Statements: $2 } }
    ;

LetStmt:
    LET IDENTIFIER ASSIGN Expression SEMICOLON {
         $$ = &LetStmt{
             NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(5)), // Pos of LET, Pos of SEMICOLON
             Variable: $2.(*IdentifierExpr),
             Value: $4,
          }
    }
    ;

AssignStmt: // Rule for simple assignment `a = b;` if needed as statement
    IDENTIFIER ASSIGN Expression SEMICOLON {
         // This might conflict with InstanceDecl's Assignment rule if not careful.
         // Let's prefer LetStmt for variables. This rule might be removed.
         // For now, map it to AssignmentStmt AST node used by InstanceDecl.
         $$ = &AssignmentStmt{
             NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(4)),
             Var: $1.(*IdentifierExpr),
             Value: $3,
         }
    }
    ;

ExprStmt:
    Expression SEMICOLON { $$ = &ExprStmt{ NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(2)), Expression: $1 } }
    ;

ReturnStmt:
    RETURN Expression SEMICOLON { $$ = &ReturnStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(3)), ReturnValue: $2 } }
    | RETURN SEMICOLON          { $$ = &ReturnStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(2)), ReturnValue: nil } }
    ;

DelayStmt:
    DELAY Expression SEMICOLON { $$ = &DelayStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(3)), Duration: $2 } }
    ;

WaitStmt:
    WAIT IDENTIFIER CommaIdentifierListOpt SEMICOLON {
         idents := []*IdentifierExpr{$2.(*IdentifierExpr)}
         endPos := lexer.PosAt(4)
         if $3 != nil {
             idents = append(idents, $3...)
             // Need end pos of the last identifier in the list
             if len($3) > 0 { endPos = $3[len($3)-1].End() }
         }
         $$ = &WaitStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), endPos), Idents: idents }
    }
    ;

CommaIdentifierListOpt:
      /* empty */                  { $$ = nil }
    | COMMA IDENTIFIER CommaIdentifierListOpt {
         $$ = []*IdentifierExpr{$2.(*IdentifierExpr)}
         if $3 != nil { $$ = append($$, $3...) }
    }
    ;

LogStmt:
    LOG Expression CommaExpressionListOpt SEMICOLON {
         args := []Expr{$2}
         endPos := lexer.PosAt(4)
         if $3 != nil {
             args = append(args, $3...)
             if len($3) > 0 { endPos = $3[len($3)-1].(Node).End() }
         }
         $$ = &LogStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), endPos), Args: args }
    }
    ;

CommaExpressionListOpt:
      /* empty */                   { $$ = nil }
    | COMMA Expression CommaExpressionListOpt {
        $$ = []Expr{$2}
        if $3 != nil { $$ = append($$, $3...) }
    }
    ;


// --- Control Flow ---
IfStmt:
    IF Expression BlockStmt IfStmtElseOpt {
        endPos := $3.(Node).End()
        if $4 != nil { endPos = $4.(Node).End() }
        $$ = &IfStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), endPos), Condition: $2, Then: $3, Else: $4 }
    }
    ;

IfStmtElseOpt:
      /* empty */         { $$ = nil }
    | ELSE IfStmt         { $$ = $2 } // Chain if-else
    | ELSE BlockStmt      { $$ = $2 } // else { ... }
    ;

DistributeStmt:
    DISTRIBUTE TotalClauseOpt LBRACE DistributeCaseListOpt DefaultCaseOpt RBRACE {
        $$ = &DistributeStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), lexer.PosAt(6)), Total: $2, Cases: $4, DefaultCase: $5 }
    }
    ;

TotalClauseOpt: /* empty */ { $$=nil } | LPAREN Expression RPAREN { $$=$2 };

DistributeCaseListOpt:
      /* empty */                  { $$ = []*DistributeCase{} }
    | DistributeCaseListOpt DistributeCase { $$ = append($1, $2) }
    ;

DistributeCase:
    Expression ARROW BlockStmt { $$ = &DistributeCase{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Probability: $1, Body: $3 } }
    ;

DefaultCaseOpt:
      /* empty */   { $$ = nil }
    | DefaultCase { $$ = $1 }
    ;

DefaultCase:
    DEFAULT ARROW BlockStmt { $$ = &DefaultCase{ NodeInfo: newNodeInfo(lexer.PosAt(1), $3.(Node).End()), Body: $3 } }
    ;

GoStmt: // Example: `go fut1 = { ... }` or `go { ... }`
    GO IDENTIFIER ASSIGN BlockStmt {
        $$ = &GoStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), $4.(Node).End()), VarName: $2.(*IdentifierExpr), Stmt: $4 }
    }
    | GO BlockStmt {
        $$ = &GoStmt{ NodeInfo: newNodeInfo(lexer.PosAt(1), $2.(Node).End()), VarName: nil, Stmt: $2 }
    }
    | GO IDENTIFIER ASSIGN Expression SEMICOLON {
         yyerror(lexer, "`go` currently only supports assigning blocks, not expressions")
         $$ = &GoStmt{} // Return dummy value on error
    }
    ;

SwitchStmt: // Placeholder
    SWITCH Expression LBRACE /* TODO */ RBRACE { yyerror(lexer, "Switch statement not defined"); $$ = nil };

// --- Expressions ---
Expression:
    OrExpr { $$ = $1 }
    ;

OrExpr: AndBoolExpr { $$=$1 }
      | OrExpr OR AndBoolExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
      ;

AndBoolExpr: CmpExpr { $$=$1 }
    | AndBoolExpr AND CmpExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    ;

CmpExpr: AddExpr { $$=$1 }
    | AddExpr EQ AddExpr  { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | AddExpr NEQ AddExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | AddExpr LT AddExpr  { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | AddExpr LTE AddExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | AddExpr GT AddExpr  { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | AddExpr GTE AddExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    ;

AddExpr: MulExpr { $$=$1 }
    | AddExpr PLUS MulExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | AddExpr MINUS MulExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    ;

MulExpr: UnaryExpr { $$=$1 }
    | MulExpr MUL UnaryExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | MulExpr DIV UnaryExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    | MulExpr MOD UnaryExpr { $$ = &BinaryExpr{ NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), Left: $1, Operator: $2, Right: $3} }
    ;

UnaryExpr: PrimaryExpr { $$=$1 }
    | NOT UnaryExpr { $$ = &UnaryExpr{ NodeInfo: newNodeInfo(lexer.PosAt(1), $2.(Node).End()), Operator: $1, Right: $2} }
    | MINUS UnaryExpr %prec UMINUS { $$ = &UnaryExpr{ NodeInfo: newNodeInfo(lexer.PosAt(1), $2.(Node).End()), Operator: $1, Right: $2} }
    ;

PrimaryExpr:
      LiteralExpr             { $$ = $1 }
    | IDENTIFIER { $$ = $1 } // Already has position info
    | MemberAccessExpr        { $$ = $1 }
    | CallExpr                { $$ = $1 }
    | DistributeExpr          { $$ = $1 } // Expression version
    // | SwitchExpr              { $$ = $1 } // Expression version
    | LPAREN Expression RPAREN { $$ = $2 } // Grouping
    ;

LiteralExpr:
      INT_LITERAL             { $$ = $1 }
    | FLOAT_LITERAL           { $$ = $1 }
    | STRING_LITERAL          { $$ = $1 }
    | BOOL_LITERAL            { $$ = $1 }
    | DURATION_LITERAL        { $$ = $1 }
    ;


MemberAccessExpr:
    PrimaryExpr DOT IDENTIFIER {
         $$ = &MemberAccessExpr{
             NodeInfo: newNodeInfo($1.(Node).Pos(), $3.(Node).End()), // Pos of Receiver, End of Identifier
             Receiver: $1,
             Member: $3.(*IdentifierExpr),
         }
    }
    ;

CallExpr:
    PrimaryExpr LPAREN RPAREN { // No args
         $$ = &CallExpr{
             NodeInfo: newNodeInfo($1.(Node).Pos(), lexer.PosAt(3)), // Pos of Function, Pos of RPAREN
             Function: $1,
             Args: []Expr{},
         }
    }
    | PrimaryExpr LPAREN ArgList RPAREN { // With args
         endPos := lexer.PosAt(4) // Default to RPAREN pos
         if len($3) > 0 { endPos = $3[len($3)-1].(Node).End() } // End at last arg
         $$ = &CallExpr{
             NodeInfo: newNodeInfo($1.(Node).Pos(), endPos), // Pos of Function, End of ArgList/RPAREN
             Function: $1,
             Args: $3,
         }
    }
    ;

ArgListOpt:
      /* empty */ { $$ = []Expr{} }
    | ArgList   { $$ = $1 }
    ;

ArgList:
    Expression                { $$ = []Expr{$1} }
    | ArgList COMMA Expression { $$ = append($1, $3) }
    ;


DistributeExpr:
    DISTRIBUTE TotalClauseOpt LBRACE DistributeExprCaseListOpt DefaultCaseExprOpt RBRACE {
         $$ = &DistributeExpr{TotalProb: $2, Cases: $4, Default: $5} /* TODO: Pos */
    }
    ;

DistributeExprCaseListOpt:
      /* empty */                         { $$ = []*DistributeExprCase{} }
    | DistributeExprCaseListOpt DistributeExprCase { $$ = append($1, $2.(*DistributeExprCase)) } // Ensure type assertion
    ;

DistributeExprCase: // Returns Expr for use in DistributeExpr struct
    Expression ARROW Expression {
        // Need to wrap in DistributeExprCase AST node
        $$ = &DistributeExprCase{ Probability: $1, Body: $3 } /* TODO: Pos */
    }
    ;

DefaultCaseExprOpt: // Returns Expr
      /* empty */       { $$ = nil }
    | DefaultCaseExpr { $$ = $1 }
    ;

DefaultCaseExpr: // Returns Expr
    DEFAULT ARROW Expression { $$ = $3 } // Return the body expression directly
    ;


SwitchExpr: // Placeholder - Needs AST definition
    SWITCH Expression LBRACE /* Case definitions */ RBRACE {
         yyerror("Switch expression not fully defined yet")
         $$ = nil
    }
    ;

CaseExpr: // Placeholder - Needs AST definition
     CASE Expression COLON Expression {
         yyerror("Case expression not fully defined yet")
         $$ = nil
     }
     ;
%% // --- Go Code Section ---

// Interface for the lexer required by the parser.
type SdlLexer interface {
    Lex(lval *yySymType) int
    Error(s string)
    // Add methods to get current position info
    Pos() int // Start position of the last token read
    End() int // End position of the last token read
    Text() string // Text of the last token read
}

// Add helper functions to get token positions, assuming %parse-param { lexer SdlLexer }
// These need to be defined within the scope accessible by semantic actions.
// Usually, they are methods on the lexer struct itself.

// PosAt retrieves the start position of the n'th component of the rule (1-based).
func (l *Lexer) PosAt(n int) int {
    // This relies on yacc internals which might store positions.
    // A common way is to access yyS[len(yyS)-n].pos if yacc stores position info
    // in the stack items. This requires inspecting the generated sdl.go or using
    // a known pattern from goyacc documentation/examples.
    // **Alternative:** If yacc doesn't store positions reliably, capture positions
    // for relevant tokens *in the lexer* and retrieve them here (more complex).
    // **Simplification for now:** Use the current lexer position as a placeholder.
    // This is NOT correct but allows compilation. Replace with actual mechanism.
    // fmt.Fprintf(os.Stderr, "Warning: PosAt(%d) returning current lexer pos (incorrect)\n", n)
    // return l.tokenStartPos // Incorrect placeholder

    // **Let's assume yacc provides access via yylex.(*yyLex).yyVALS[index]**
    // This requires knowing how goyacc maps $N to the stack. Often it's yyVALS[N-1] offset from top?
    // This is fragile. Let's try storing positions on the AST nodes passed up.
    // **Revised Simplification:** Get position from the Node itself passed via $N
    // Need type assertion. This requires ALL tokens passed up ($N) to be Node.
    val := l.getNodeValue(n) // Need helper to get $N value safely
    if node, ok := val.(Node); ok {
        return node.Pos()
    }
    // Fallback if $N wasn't a Node (e.g., just a token value) - use lexer pos (still not ideal)
    // fmt.Fprintf(os.Stderr, "Warning: PosAt(%d) could not get pos from Node, using current lexer pos\n", n)
    return l.tokenStartPos
}

// EndAt retrieves the end position of the n'th component (1-based).
func (l *Lexer) EndAt(n int) int {
    val := l.getNodeValue(n)
    if node, ok := val.(Node); ok {
        return node.End()
    }
    // Fallback
    // fmt.Fprintf(os.Stderr, "Warning: EndAt(%d) could not get pos from Node, using current lexer pos\n", n)
    return l.pos
}

// getNodeValue is a placeholder for safely accessing the value of $N.
// The actual mechanism depends on how goyacc/parse-param works.
// This might involve accessing a stack directly if %parse-param doesn't make $N values directly available.
// We assume for now that the parser stack value IS the value associated with $N.
// In practice, you'd access yacc's internal stack like yyVAL[index].
func (l *Lexer) getNodeValue(n int) any {
    // This is a placeholder and needs actual implementation based on goyacc internals
    // fmt.Fprintf(os.Stderr, "Warning: getNodeValue(%d) is a placeholder\n", n)
    return nil // Needs real implementation
}

// The parser expects the lexer variable to be named yyLex.
// We can satisfy this by creating a global or passing it via yyParseWithLexer.
// Using yyParseWithLexer is cleaner.

// Parse takes an input stream and attempts to parse it according to the SDL grammar.
// It returns the root of the Abstract Syntax Tree (*File) if successful, or an error.
func Parse(input io.Reader) (*File, error) {
  lexer := NewLexer(input)
  // Set yyDebug = 3 for verbose parser debugging output
  // yyDebug = 3
  // Call yyParse with the lexer instance
  resultCode := yyParse(lexer) // Pass lexer instance here

	if resultCode != 0 {
		// An error occurred during parsing (syntax error)
		// The lexer's Error method should have been called.
    // We might have partial results in parseResult, but return error.
		// The lexer should store the error message.
    if lexer.lastError == nil {
            return nil, lexer.lastError
        }
    return nil, fmt.Errorf("syntax error near byte %d", lexer.Pos())
	}

  // Success - retrieve result stored in the lexer instance
	if parseResult == nil {
         // This shouldn't happen if grammar has a start rule assigning to parseResult
    return nil, fmt.Errorf("parsing finished successfully, but no AST result was produced")
    }
    return lexer.parseResult, nil
}

// Example main function (optional, for standalone testing)
/*
func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: parser <input_file>")
		return
	}
	filePath := os.Args[1]
	file, err := os.Open(filePath)
	if err != nil {
		fmt.Printf("Error opening file %s: %v\n", filePath, err)
		return
	}
	defer file.Close()

	astRoot, err := Parse(file)
	if err != nil {
		fmt.Printf("Parsing failed: %v\n", err)
		// Error message should ideally include line/column from lexer
	} else {
		fmt.Println("Parsing successful!")
		// Print the AST (implement String() methods for AST nodes for nice output)
		fmt.Println(astRoot.String())
	}
}
*/
