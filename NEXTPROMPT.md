
**Next Steps (Phase 4 - DSL Interpreter/VM):**

**Project Context:**

You are continuing development on the SDL (System Design Language) Go library. This library models steady-state system performance using probabilistic `Outcomes` distributions and analytical components (`sdl/core`, `sdl/components`). It prioritizes analytical speed over discrete-event simulation. Key components (`ResourcePool`) are now stateless and rate-driven. A standardized testing primitive (`core.Analyze`) is used extensively.

**Current State:**
- A new declarative layer (`sdl/decl`) has been implemented.
    - `sdl/decl/ast/ast.go` defines AST nodes (`LiteralExpr`, `IdentifierExpr`, `CallExpr`, `AndExpr`, `ParallelExpr`, `InternalCallExpr`, `RepeatExpr`, `FanoutExpr`, etc.).
    - `sdl/decl/components.go` defines declarative component structs holding configuration and methods (`*AST()`) that generate these `ast.Expr` trees, representing operations rather than executing them directly. Tests verify correct AST generation.
- The core library (`sdl/core`) provides the building blocks: `Outcomes[V]`, composition functions (`And`, `Map`, `Split`), result types (`AccessResult`), reduction (`TrimToSize`), metrics (`Availability`, etc.), and distribution helpers (`NewDistributionFromPercentiles`).
- Known limitations (steady-state focus, stateless pool, parallel composition approximations, missing `Filter`/`Repeat`/`FanoutAnd` primitives) are documented. Design documents (`DSL.md`, `ROADMAP.MD`) outline the overall plan.

**Phase 4 Goal:** Focus on Usability & System Composition.

**Next Task (Phase 4, Task 2): Implement the DSL Interpreter / VM**

Your primary task is to **implement the initial version of the interpreter/VM** that can execute the Abstract Syntax Trees (ASTs) generated by the `sdl/decl` package. This VM will orchestrate calls to the `sdl/core` library functions to perform the actual probabilistic calculations.

**Requirements:**

1.  **Location:** Implement the core interpreter logic likely in `sdl/dsl/interpreter.go` (or `vm.go`).
2.  **Input:** The interpreter should take an `ast.Expr` as input (typically the target expression from an `analyze` block or a component operation's body).
3.  **Execution Model:** Implement a **stack-based execution model**. Expressions are evaluated, pushing their results (primarily `*core.Outcomes[V]` objects) onto the VM stack. Operators consume operands from the stack and push results back.
4.  **Environment:** Implement a basic environment (symbol table) for resolving identifiers (`ast.IdentifierExpr`) to runtime values (e.g., component instances created during system setup, intermediate results stored in variables). Handle basic scoping if necessary later.
5.  **Instruction Handlers (Eval Logic):** Implement evaluation logic for key AST nodes:
    *   **`ast.LiteralExpr`:** Parse value, wrap in a deterministic `*core.Outcomes[T]`, push onto stack.
    *   **`ast.IdentifierExpr`:** Look up name in environment, push value onto stack.
    *   **`ast.CallExpr`:** Evaluate function expression, evaluate args, resolve Go method/function, call it (it might return `*core.Outcomes[V]` directly or another `ast.Expr` to evaluate recursively), push result. Handle calls to `sdl/decl` component `*AST()` methods by recursively evaluating the returned AST.
    *   **`ast.MemberAccessExpr`:** Evaluate receiver, use member name for method lookup (in `CallExpr`) or potentially field access later.
    *   **`ast.AndExpr`:** Evaluate `Left`, evaluate `Right`. Pop both results (`*Outcomes[V1]`, `*Outcomes[V2]`). **Inspect types V1/V2** (using type assertions/reflection initially). Select appropriate **sequential reducer** (e.g., `core.AndAccessResults`). Call `core.And(LeftResult, RightResult, reducer)`. **Apply intermediate trimming** based on context/options. Push result.
    *   **`ast.ParallelExpr`:** Similar to `AndExpr`, but select/implement a **parallel reducer** (approximate: Max Latency, AND Success for known types). Call `core.And` with this parallel reducer. Apply trimming. Push result.
    *   **`ast.InternalCallExpr`:** Lookup `FuncName` in a registry of internal VM helper functions (e.g., `GetDiskReadProfile`, `CalculateBTreeHeight`, `ScaleLatency`). Evaluate args, execute the helper Go function, push result.
6.  **Intermediate Trimming:** Implement logic within the VM handlers for composition operators (`AndExpr`, `ParallelExpr`, `RepeatExpr`, `FanoutExpr`) to check the length of the resulting `Outcomes` object and apply the appropriate `core.TrimToSize` (or similar) function if it exceeds a configured threshold (`MaxOutcomeLen` from options/context). Type inspection is needed here too.
7.  **Type Handling:** The VM *must* handle type heterogeneity. Use type assertions (`switch v := value.(type)`) or reflection (`reflect` package) on the `*core.Outcomes[V]` objects popped from the stack to determine the underlying type `V` when selecting reducers, trimmers, or specific logic.
8.  **Initial Focus:** Implement handlers for `LiteralExpr`, `IdentifierExpr`, `CallExpr` (calling simple Go funcs returning `Outcomes`), `AndExpr`, and `InternalCallExpr` (with a few basic helpers like `GetDiskReadProfile`). Implement the basic stack machine loop and intermediate trimming after `AndExpr`.

**Do Not Implement Yet:** `RepeatExpr`, `FanoutExpr`, `SwitchExpr`, `FilterExpr`, complex environment scoping, full DSL parsing integration (assume AST input is given).

**Deliverable:** Go code for the initial stack-based VM/Interpreter (`interpreter.go` and supporting types/environment struct). Include basic tests (`interpreter_test.go`) that construct simple ASTs manually and verify the interpreter produces the expected final `*core.Outcomes[V]` result on the stack (check `Len()`, `TotalWeight()`, maybe `Availability()` if applicable).
