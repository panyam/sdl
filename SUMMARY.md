# SDL (System Design Language) Project Summary

**Version:** As of the implementation of simulation analysis commands.

**1. Vision & Goal:**

*   **Purpose:** The SDL project provides a specialized language and a powerful toolchain for modeling, simulating, and analyzing the performance characteristics (e.g., latency, availability, result distribution) of distributed systems.
*   **Use Cases:** Enable rapid analysis of system designs, bottleneck identification, SLO evaluation, performance exploration under different configurations, and generating diagrams from the definitions.

**2. Overall Architecture & Key Packages:**

The project is a Go-based system composed of several key packages:

*   **`./core` & `./components`:** Provide a Go API for probabilistic performance modeling (`core`) and a library of pre-built native components like disks, caches, and queues (`components`).
*   **`./decl` & `./parser`:** Define the language's Abstract Syntax Tree (AST) and implement the `goyacc`-based parser to generate the AST from `.sdl` files.
*   **`./loader`:** Manages the loading of SDL files, resolving imports, and orchestrating the crucial type inference and validation phase.
*   **`./runtime`:** The execution engine for SDL models. It features `SimpleEval`, an interpreter that walks the AST to run simulations, accumulating latency and tracking results. It has been enhanced to handle basic concurrency placeholders and provide better error reporting.
*   **`./cmd/sdl` (Command Line Interface):** The main user-facing tool, `sdl`, built with Cobra. It provides a suite of commands for a comprehensive workflow:
    *   **`validate`**: Parses and type-checks SDL files.
    *   **`list` / `describe`**: Inspects and prints details about components and systems.
    *   **`diagram static`**: Generates static system diagrams in multiple formats (DOT, Mermaid, Excalidraw, SVG).
    *   **`run`**: A powerful simulation runner. It executes a specific system method thousands of times to gather statistical data. It produces a detailed JSON file containing the end-to-end latency and return value for every single run.
    *   **`plot`**: A flexible post-simulation analysis tool. It consumes the JSON file generated by `sdl run` to create plots. It can generate both **latency percentile charts** (P50, P90, P99) and **multi-series count charts** (e.g., graphing the rate of `HttpStatusCode.Ok` vs. `HttpStatusCode.InternalError` over time).
    *   **`trace`**: (Placeholder) For future single-run detailed execution tracing.

*   **`./examples`:** Contains sample `.sdl` files (like the Twitter model) used for testing and demonstration, as well as examples of using the core Go API.

**3. Current Status & Key Features:**

*   **Robust Core & Frontend:** The project has mature libraries for performance modeling, a robust parser, and a powerful type inference system.
*   **End-to-End Simulation Workflow:** The most significant feature is the complete workflow for performance analysis via simulation:
    1.  Define a system in an `.sdl` file.
    2.  Use **`sdl run`** to execute a high-volume simulation.
    3.  Use **`sdl plot`** to visualize the results, analyzing both latency and the distribution of outcomes.
*   **Advanced Plotting:** The plotter can generate multi-series SVG charts with legends, enabling rich analysis of result counts over time.
*   **Static Analysis:** The `validate` and `diagram static` commands provide strong static analysis and documentation capabilities.
*   **Known Limitations:** While placeholders exist, true runtime support for the `go`, `gobatch`, and `wait` concurrency primitives is the next major step. Full, deep execution tracing for dynamic diagrams is also a future goal.

This summary provides a high-level overview of the SDL project, its architecture, and its current, powerful simulation and analysis capabilities.
