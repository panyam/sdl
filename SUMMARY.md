# SDL Project Summary & Onboarding Guide

**1. Vision & Goal:**

*   **Purpose:** The SDL (System Design Language) library models and analyzes the performance characteristics (latency, availability) of distributed system components using **analytical models** and **probabilistic composition**. It prioritizes **speed** for interactive "what-if" analysis over detailed Discrete Event Simulation (DES), focusing primarily on **steady-state** behavior.
*   **Use Cases:** Enable rapid analysis of system designs, bottleneck identification, SLO evaluation, performance exploration under different configurations, and potentially educational tools for system design reasoning.

**2. Overall Architecture:**

*   **Probabilistic Core (`sdl/core`):** The foundation, providing generic `Outcomes[V]` distributions, composition operators (`And`, `Map`, `Split`, `Append`), complexity management via reduction (`Trim...`, `Merge...`, etc.), metric calculations (`Availability`, `PercentileLatency`, etc.), and a standardized `Analyze` primitive for testing.
*   **Analytical Components (`sdl/components`):** Concrete Go models of system building blocks (Disk, Cache, Queue, Pool, LSM, BTree, etc.) using `sdl/core`. Key components (`ResourcePool`, `Queue`) use stateless analytical formulas (M/M/c, M/M/c/K).
*   **Declarative Layer (`sdl/components/decl`):** Defines component structures and methods (`*AST()`) that generate Abstract Syntax Trees (ASTs) representing operation logic, separating definition from execution.
*   **DSL Execution Engine (`sdl/dsl`):** Contains the AST definition (`ast.go`), the Interpreter/VM (`interpreter.go`, `eval_*.go`), Environment (`environment.go`), and Driver (`driver.go`). The interpreter executes ASTs generated by `decl` (or potentially a future parser), orchestrating calls to `sdl/core` primitives and managing type-specific logic and intermediate reduction via a Reducer Registry.
*   **Examples (`sdl/examples`):** Demonstrates usage of the Go API to build and analyze systems (`bitly`, `gpucaller`, `notifier`).

**3. Code Structure & Package Overview:**

*   **`sdl/` (Root)**
    *   `go.mod`, `go.sum`: Go module definitions.
    *   `Makefile`: Build/test/watch commands.
    *   `DSL.md`, `ROADMAP.MD`: Design notes and future plans.
    *   `SUMMARY.md`: (This document) Project overview.
    *   `NEXTSTEPS.md`: Outstanding tasks and future work.
    *   *(Future)* `README.md`: High-level description and usage examples.

*   **`sdl/core/`**: Fundamental, generic types and operations. (See `sdl/core/SUMMARY.md`).
*   **`sdl/components/`**: Concrete system building blocks using `sdl/core`. Includes `decl/` sub-package for AST generation. (See `sdl/components/SUMMARY.md`).
*   **`sdl/dsl/`**: DSL Interpreter/VM and AST definitions. Parser TBD. (See `sdl/dsl/SUMMARY.md`).
*   **`sdl/examples/`**: Examples using the Go API. (See `sdl/examples/SUMMARY.md`).

**4. Current Status & Recent Work Summary:**

*   The core analytical library (`sdl/core`, `sdl/components`) is functional for modelling steady-state performance via probabilistic composition using the Go API. Standardized testing via `core.Analyze` is implemented. Key components are stateless and rate-driven.
*   The declarative layer (`sdl/decl`) generates ASTs for component operations.
*   The **DSL Interpreter (`sdl/dsl`)** is partially implemented:
    *   Core structures (Interpreter, Env, Stack, Registry) are in place.
    *   Evaluation logic exists for: Literals, Identifiers, Internal Calls, Method Calls (incl. recursive AST eval), Sequential `And` (implicit and explicit), `Repeat` (sequential), `If` (incl. `.Success`), Assignments, Blocks, Returns.
    *   Argument handling for method calls (deterministic args) is implemented.
    *   A Reducer Registry handles type combinations for sequential `And`.
    *   A basic Driver (`RunDSL`) can instantiate systems from ASTs and run `analyze` targets.
*   **Recent Work:** Focused heavily on implementing the DSL Interpreter phases. Refactored combination logic to use a Reducer Registry. Implemented argument handling. Created the top-level driver.

**5. Known Limitations (Explicitly Acknowledged):**

*   **Analytical Steady-State:** Models average performance, not transient bursts/dynamics. Accuracy depends on analytical models (e.g., M/M/c assumptions).
*   **Stateless Components:** `ResourcePool`/`Queue` rely purely on configured rates.
*   **Profile Accuracy:** Depends on realistic input `Outcomes` distributions.
*   **Approximations:** Batcher wait time, parallel execution (`Repeat`/`FanoutAnd` logic pending), fan-out costs in examples.
*   **Cold Starts/Scaling/Network Details:** Not inherently modeled, require external handling or explicit components/adjustments.
*   **Interpreter Incomplete:** Missing evaluators for `ParallelExpr`, `FanoutExpr`, `FilterExpr`, `SwitchExpr`. Parser not implemented. Error handling needs refinement. Full component instantiation logic (params, uses) in driver needs completion.
*   **DSL Value Access:** Currently disallows direct access to inner values (e.g., latency) from `Outcomes` variables within DSL logic.

**6. Next Steps:**

*   Focus on completing the core Interpreter/VM functionality as outlined in `NEXTSTEPS.md`.
*   Implement the DSL Parser.
*   Refine error handling, testing, and documentation.
