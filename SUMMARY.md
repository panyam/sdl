# SDL Project Summary & Onboarding Guide

**1. Vision & Goal:**

*   **Purpose:** The SDL (System Design Language) library models and analyzes the performance characteristics (latency, availability) of distributed system components using **analytical models** and **probabilistic composition**. It prioritizes **speed** for interactive "what-if" analysis over detailed Discrete Event Simulation (DES), focusing primarily on **steady-state** behavior.
*   **Use Cases:** Enable rapid analysis of system designs, bottleneck identification, SLO evaluation, performance exploration under different configurations, and potentially educational tools for system design reasoning.

**2. Overall Architecture:**

*   **Probabilistic Core (`sdl/core`):** The foundation, providing generic `Outcomes[V]` distributions, composition operators (`And`, `Map`, `Split`, `Append`), complexity management via reduction (`Trim...`, `Merge...`, etc.), metric calculations (`Availability`, `PercentileLatency`, etc.), and a standardized `Analyze` primitive for testing the Go API. Relies on external reducers for composition.
*   **Analytical Components (`sdl/components`):** Concrete Go models of system building blocks (Disk, Cache, Queue, Pool, LSM, BTree, etc.) using `sdl/core`. Key components (`ResourcePool`, `Queue`) use stateless analytical formulas (M/M/c, M/M/c/K).
*   **Declarative Layer (`sdl/components/decl`):** Defines component structures and methods (`Read()`, `Find()`, etc.) that generate Abstract Syntax Trees (ASTs) representing operation logic, separating definition from execution.
*   **DSL Execution Engine (`sdl/dsl`):** Contains the AST definition (`ast.go`), the VM/VM (`vm.go`, `eval_*.go`), Environment (`environment.go`), and Driver (`driver.go`). The vm executes ASTs generated by `decl` (or a future parser), orchestrating calls to `sdl/core` primitives and managing the implicit tracking of value and latency distributions (Model V4). It uses a Reducer Registry primarily for latency combination.
*   **Examples (`sdl/examples`):** Demonstrates usage of the **Go API** to build and analyze systems (`bitly`, `gpucaller`, `notifier`).

**3. Code Structure & Package Overview:**

*   **`sdl/` (Root)**
    *   `go.mod`, `go.sum`: Go module definitions.
    *   `Makefile`: Build/test/watch commands.
    *   `DSL.md`, `ROADMAP.MD` (Potentially outdated): Design notes and future plans.
    *   `SUMMARY.md`: (This document) Project overview.
    *   `NEXTSTEPS.md`: Outstanding tasks and future work.
    *   `sdl/SYNTAX.md`: DSL syntax design discussion and decisions.
    *   *(Future)* `README.md`: High-level description and usage examples.

*   **`sdl/core/`**: Fundamental, generic types and operations. (See `sdl/core/SUMMARY.md`).
*   **`sdl/components/`**: Concrete system building blocks using `sdl/core`. Includes `decl/` sub-package for AST generation. (See `sdl/components/SUMMARY.md`).
*   **`sdl/dsl/`**: DSL VM/VM and AST definitions. Parser TBD. (See `sdl/dsl/SUMMARY.md`).
*   **`sdl/examples/`**: Examples using the Go API. (See `sdl/examples/SUMMARY.md`).

**4. Current Status & Recent Work Summary:**

*   The core analytical library (`sdl/core`, `components`) is functional for modelling steady-state performance via probabilistic composition using the **Go API**. Standardized testing via `core.Analyze` is implemented. Key components are stateless and rate-driven.
*   The declarative layer (`sdl/decl`) generates ASTs for component operations.
*   The **DSL VM (`sdl/dsl`)** is partially implemented:
    *   Core structures (VM, Env, Stack, Reducer Registry) are in place.
    *   Evaluation logic exists for: Literals, Identifiers, `AndExpr`, `CallExpr` (supporting Go methods returning Outcomes/AST, deterministic args), `InternalCallExpr`, Statements (`BlockStmt`, `AssignmentStmt`, `ReturnStmt`, `ExprStmt`, `IfStmt`), `RepeatExpr`, `MemberAccessExpr`.
    *   A basic Driver (`RunDSL`) can instantiate systems from ASTs and run `analyze` targets, calculating and returning metrics.
    *   **DSL Design Decision:** Converged on **Model V4 (Implicit Outcomes + Discrete Values + Explicit Delay)**. This requires refactoring the VM to track value and latency distributions implicitly.
*   **Recent Work:** Focused on implementing DSL VM statement/expression evaluators, establishing the driver structure, and refining the target DSL design (Model V4).

**5. Known Limitations (Explicitly Acknowledged):**

*   **Analytical Steady-State:** Models average performance, not transient bursts/dynamics. Accuracy depends on analytical models (e.g., M/M/c assumptions).
*   **Stateless Components:** `ResourcePool`/`Queue` rely purely on configured rates.
*   **Profile Accuracy:** Depends on realistic input `Outcomes` distributions (especially for leaf components like `Disk` or work profiles like `gpuwork`).
*   **Approximations:** Batcher wait time, parallel execution modeling (pending), fan-out costs in examples.
*   **VM Incomplete:** Requires significant refactoring to fully implement Model V4 (dual value/latency tracking). Evaluators for `ParallelExpr`, `FanoutExpr`, `FilterExpr`, `SwitchExpr`, `distribute`, `delay` are missing. Driver needs refinement (params, dependencies). Error handling needs improvement.
*   **DSL Parser Not Implemented:** Currently relying on manually constructed ASTs or ASTs generated by `decl`.
*   **DSL Value Access:** Currently disallows direct access to inner continuous values (e.g., latency) from variables within DSL logic, although access to discrete fields (e.g., `.StatusCode`, `.Success`) for conditions is intended.

**6. Next Steps:**

*   Focus on refactoring the VM and implementing missing evaluators to fully realize **Model V4** for the DSL.
*   Implement the DSL Parser.
*   Refine error handling, testing (including DSL-specific tests), and documentation.
*   See `NEXTSTEPS.md` for a detailed breakdown.
