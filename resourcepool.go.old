package sdl

import (
	"sync" // Import sync package for Mutex later if needed
)

// AcquireAttemptResult represents the outcome of trying to acquire a resource.
type AcquireAttemptResult struct {
	Success bool          // True if acquired, False otherwise
	Pool    *ResourcePool // Pointer back to the pool (needed for Release)
	// Latency Duration // Could add latency later for queuing
}

// ResourcePool models a pool of limited, identical resources (e.g., connections, threads).
type ResourcePool struct {
	Name string // Optional identifier
	Size uint   // Maximum number of concurrent users/holders
	Used uint   // Current number of resources in use

	// Mutex for protecting access to Used count in future concurrent simulations
	// For now, operations are assumed sequential within a simulation run.
	mu sync.Mutex // Not strictly needed yet, but good practice to include

	// Pre-calculated outcomes for Acquire (success/failure)
	// These need to be generated dynamically based on current state (Used vs Size)
	// acquireSuccessOutcome *Outcomes[AcquireAttemptResult]
	// acquireFailureOutcome *Outcomes[AcquireAttemptResult]
}

// Init initializes the ResourcePool.
func (rp *ResourcePool) Init(name string, size uint) *ResourcePool {
	rp.Name = name
	if size == 0 {
		// log.Printf("Warning: ResourcePool '%s' initialized with size 0. No resources can ever be acquired.", name)
		size = 0 // Ensure it's explicitly zero
	}
	rp.Size = size
	rp.Used = 0 // Start empty

	// Note: Outcomes cannot be fully pre-calculated as they depend on dynamic state 'Used'.
	// We will generate them on the fly in Acquire().

	return rp
}

// NewResourcePool creates and initializes a new ResourcePool component.
func NewResourcePool(name string, size uint) *ResourcePool {
	rp := &ResourcePool{}
	return rp.Init(name, size)
}

// Acquire attempts to acquire one resource from the pool.
// Returns an Outcome distribution representing immediate success or failure.
func (rp *ResourcePool) Acquire() *Outcomes[AcquireAttemptResult] {
	// --- CRITICAL: State Management ---
	// In a real concurrent simulator, this section needs locking.
	// For sequential simulation via And/If composition, this direct state
	// modification is problematic because the state change needs to persist
	// across the different outcome paths generated by And/If.
	//
	// WORKAROUND (for sequential simulation):
	// We return an outcome that REPRESENTS the probability of success/failure
	// based on the state *at the time of the call*, but we DON'T modify
	// rp.Used here directly. The modification must happen conceptually *after*
	// a successful outcome is chosen AND before the work using the resource starts.
	// This is HARD to enforce with current combinators.
	//
	// --- SIMPLIFIED MODEL (Ignoring state persistence issue for now): ---
	// Generate outcomes based on current state, assume sequential execution handles it.

	rp.mu.Lock() // Lock even for sequential, good practice
	canAcquire := rp.Used < rp.Size
	// Note: We are NOT changing rp.Used here in this simplified model yet.
	rp.mu.Unlock()

	outcomes := &Outcomes[AcquireAttemptResult]{
		// Define an And function if needed for composing AcquireAttemptResult later
		And: func(a, b AcquireAttemptResult) AcquireAttemptResult {
			// If either acquire failed, the combined result is failure.
			// If both succeeded, it's success. Pool context would be from 'a'.
			return AcquireAttemptResult{Success: a.Success && b.Success, Pool: a.Pool}
		},
	}

	if canAcquire {
		// Success: Acquired the resource immediately
		outcomes.Add(1.0, AcquireAttemptResult{
			Success: true,
			Pool:    rp,
			// Latency: 0 (or very small CPU cost?)
		})
		// log.Printf("Pool '%s': Acquire SUCCESS (Used=%d, Size=%d)", rp.Name, rp.Used, rp.Size) // Debugging (state before acquire)

	} else {
		// Failure: Pool is full
		outcomes.Add(1.0, AcquireAttemptResult{
			Success: false,
			Pool:    rp,
			// Latency: 0 (immediate rejection)
		})
		// log.Printf("Pool '%s': Acquire FAILURE (Used=%d, Size=%d)", rp.Name, rp.Used, rp.Size) // Debugging
	}

	return outcomes
}

// Release returns one resource to the pool.
// This is modelled as an instantaneous operation.
// !! IMPORTANT !! This method directly modifies state. In a proper simulation
// using the Outcomes model, Release should ideally be triggered *by* an outcome
// from the preceding operation, not called directly like this after an And/If chain.
func (rp *ResourcePool) Release() {
	rp.mu.Lock()
	defer rp.mu.Unlock()

	if rp.Used > 0 {
		rp.Used--
		// log.Printf("Pool '%s': Released resource (Used=%d, Size=%d)", rp.Name, rp.Used, rp.Size) // Debugging
	} else {
		// log.Printf("Warning: Pool '%s': Release called when Used count is zero.", rp.Name)
	}
}

// --- How to USE ResourcePool with current Outcomes model (Conceptual) ---
/*
func ExampleOperationUsingPool(pool *ResourcePool, work func() *Outcomes[AccessResult]) *Outcomes[AccessResult] {

    acquireOutcome := pool.Acquire() // Get {Success:bool, Pool:*ResourcePool} outcomes

    // If acquire SUCCEEDS, then perform work AND THEN release.
    // If acquire FAILS, return failure immediately.

    // This requires careful composition:
    finalOutcome := acquireOutcome.If(
        func(aq AcquireAttemptResult) bool { return aq.Success }, // Condition: Acquired successfully?
        // THEN branch (Acquire Succeeded):
        And(
            work(), // Perform the actual work, get its AccessResult outcomes
            // ??? How to trigger Release reliably AFTER work is done for EACH work outcome ???
            // This is the tricky part. We need to combine the work outcome with the Release action.
            // Maybe the reducer modifies the pool state? Risky.
            // Maybe Map work outcomes to a new type that includes release intent?
            Map(work(), func(workResult AccessResult) AccessResult {
                 // !!! This is where the state needs update !!! conceptually release here.
                 // pool.Release() // <<<<<<<<< Cannot safely call stateful method here in pure model
                 return workResult // Return original work result
            }),
            AndAccessResults, // Placeholder reducer
        ),
        // OTHERWISE branch (Acquire Failed):
        // Map the AcquireAttemptResult failure to an AccessResult failure.
        Map(acquireOutcome, // Need to filter for failures here? Split might be better.
            func(aq AcquireAttemptResult) AccessResult {
                if !aq.Success {
                    return AccessResult{Success: false, Latency: 0} // Immediate failure from pool rejection
                }
                // This path shouldn't be taken if condition was aq.Success==true
                // Return some default or error state?
                return AccessResult{Success: false, Latency: 0} // Default failure
            }),
        AndAccessResults, // Placeholder reducer
    )

    // The above 'If' structure doesn't correctly handle the stateful Release.
    // A more simulationist approach might be needed for proper state handling.

    // --- SIMPLER but less accurate model for now: ---
    // Assume Acquire gives AccessResult (Success=Acquired, Latency=QueueTime=0 for now)
    // Assume Release happens magically.
    simpleAcquire := Map(pool.Acquire(), func(aq AcquireAttemptResult) AccessResult {
         // Map Acquire failure to AccessResult failure
         return AccessResult{ Success: aq.Success, Latency: 0 }
    })

    // Combine Acquire -> Work. Release is ignored in this simplified flow.
    result := And(simpleAcquire, work(), AndAccessResults)
    return result
}

*/
