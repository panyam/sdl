// protos/sdl/v1/canvas.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: sdl/v1/canvas.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CanvasService_CreateCanvas_FullMethodName       = "/sdl.v1.CanvasService/CreateCanvas"
	CanvasService_ListCanvases_FullMethodName       = "/sdl.v1.CanvasService/ListCanvases"
	CanvasService_GetCanvas_FullMethodName          = "/sdl.v1.CanvasService/GetCanvas"
	CanvasService_LoadFile_FullMethodName           = "/sdl.v1.CanvasService/LoadFile"
	CanvasService_UseSystem_FullMethodName          = "/sdl.v1.CanvasService/UseSystem"
	CanvasService_DeleteCanvas_FullMethodName       = "/sdl.v1.CanvasService/DeleteCanvas"
	CanvasService_ResetCanvas_FullMethodName        = "/sdl.v1.CanvasService/ResetCanvas"
	CanvasService_AddGenerator_FullMethodName       = "/sdl.v1.CanvasService/AddGenerator"
	CanvasService_StartAllGenerators_FullMethodName = "/sdl.v1.CanvasService/StartAllGenerators"
	CanvasService_StopAllGenerators_FullMethodName  = "/sdl.v1.CanvasService/StopAllGenerators"
	CanvasService_ListGenerators_FullMethodName     = "/sdl.v1.CanvasService/ListGenerators"
	CanvasService_GetGenerator_FullMethodName       = "/sdl.v1.CanvasService/GetGenerator"
	CanvasService_UpdateGenerator_FullMethodName    = "/sdl.v1.CanvasService/UpdateGenerator"
	CanvasService_StopGenerator_FullMethodName      = "/sdl.v1.CanvasService/StopGenerator"
	CanvasService_StartGenerator_FullMethodName     = "/sdl.v1.CanvasService/StartGenerator"
	CanvasService_DeleteGenerator_FullMethodName    = "/sdl.v1.CanvasService/DeleteGenerator"
	CanvasService_ExecuteTrace_FullMethodName       = "/sdl.v1.CanvasService/ExecuteTrace"
	CanvasService_TraceAllPaths_FullMethodName      = "/sdl.v1.CanvasService/TraceAllPaths"
	CanvasService_SetParameter_FullMethodName       = "/sdl.v1.CanvasService/SetParameter"
	CanvasService_GetParameters_FullMethodName      = "/sdl.v1.CanvasService/GetParameters"
	CanvasService_BatchSetParameters_FullMethodName = "/sdl.v1.CanvasService/BatchSetParameters"
	CanvasService_EvaluateFlows_FullMethodName      = "/sdl.v1.CanvasService/EvaluateFlows"
	CanvasService_GetFlowState_FullMethodName       = "/sdl.v1.CanvasService/GetFlowState"
	CanvasService_AddMetric_FullMethodName          = "/sdl.v1.CanvasService/AddMetric"
	CanvasService_DeleteMetric_FullMethodName       = "/sdl.v1.CanvasService/DeleteMetric"
	CanvasService_ListMetrics_FullMethodName        = "/sdl.v1.CanvasService/ListMetrics"
	CanvasService_QueryMetrics_FullMethodName       = "/sdl.v1.CanvasService/QueryMetrics"
	CanvasService_StreamMetrics_FullMethodName      = "/sdl.v1.CanvasService/StreamMetrics"
	CanvasService_GetSystemDiagram_FullMethodName   = "/sdl.v1.CanvasService/GetSystemDiagram"
	CanvasService_GetUtilization_FullMethodName     = "/sdl.v1.CanvasService/GetUtilization"
)

// CanvasServiceClient is the client API for CanvasService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// *
// Service for interacting with a canvas.
type CanvasServiceClient interface {
	// *
	// Create a new canvas sesssion.
	CreateCanvas(ctx context.Context, in *CreateCanvasRequest, opts ...grpc.CallOption) (*CreateCanvasResponse, error)
	// *
	// List all canvases from a user.
	ListCanvases(ctx context.Context, in *ListCanvasesRequest, opts ...grpc.CallOption) (*ListCanvasesResponse, error)
	// *
	// Get details/stats for a particular canvas
	GetCanvas(ctx context.Context, in *GetCanvasRequest, opts ...grpc.CallOption) (*GetCanvasResponse, error)
	LoadFile(ctx context.Context, in *LoadFileRequest, opts ...grpc.CallOption) (*LoadFileResponse, error)
	UseSystem(ctx context.Context, in *UseSystemRequest, opts ...grpc.CallOption) (*UseSystemResponse, error)
	// *
	// Delete a particular canvas.  Frees up resources used by it and all the connections
	DeleteCanvas(ctx context.Context, in *DeleteCanvasRequest, opts ...grpc.CallOption) (*DeleteCanvasResponse, error)
	// *
	// Reset a canvas - clears all state, generators, and metrics
	ResetCanvas(ctx context.Context, in *ResetCanvasRequest, opts ...grpc.CallOption) (*ResetCanvasResponse, error)
	//	----- Generator Operations -----
	//
	// Adds a generator to a canvas's generator_ids list and creates the generator resource.
	AddGenerator(ctx context.Context, in *AddGeneratorRequest, opts ...grpc.CallOption) (*AddGeneratorResponse, error)
	// Request to start all generators
	StartAllGenerators(ctx context.Context, in *StartAllGeneratorsRequest, opts ...grpc.CallOption) (*StartAllGeneratorsResponse, error)
	// Request to start all generators
	StopAllGenerators(ctx context.Context, in *StopAllGeneratorsRequest, opts ...grpc.CallOption) (*StopAllGeneratorsResponse, error)
	ListGenerators(ctx context.Context, in *ListGeneratorsRequest, opts ...grpc.CallOption) (*ListGeneratorsResponse, error)
	GetGenerator(ctx context.Context, in *GetGeneratorRequest, opts ...grpc.CallOption) (*GetGeneratorResponse, error)
	// Use PATCH for partial updates to a generator (title, content)
	UpdateGenerator(ctx context.Context, in *UpdateGeneratorRequest, opts ...grpc.CallOption) (*UpdateGeneratorResponse, error)
	StopGenerator(ctx context.Context, in *StopGeneratorRequest, opts ...grpc.CallOption) (*StopGeneratorResponse, error)
	StartGenerator(ctx context.Context, in *StartGeneratorRequest, opts ...grpc.CallOption) (*StartGeneratorResponse, error)
	DeleteGenerator(ctx context.Context, in *DeleteGeneratorRequest, opts ...grpc.CallOption) (*DeleteGeneratorResponse, error)
	// Execute a single trace for debugging/analysis
	ExecuteTrace(ctx context.Context, in *ExecuteTraceRequest, opts ...grpc.CallOption) (*ExecuteTraceResponse, error)
	// Execute breadth-first traversal to find all possible execution paths
	TraceAllPaths(ctx context.Context, in *TraceAllPathsRequest, opts ...grpc.CallOption) (*TraceAllPathsResponse, error)
	// ----- Parameter Operations -----
	// Set a component parameter value
	SetParameter(ctx context.Context, in *SetParameterRequest, opts ...grpc.CallOption) (*SetParameterResponse, error)
	// Get parameter values
	GetParameters(ctx context.Context, in *GetParametersRequest, opts ...grpc.CallOption) (*GetParametersResponse, error)
	// Batch set multiple parameters atomically
	BatchSetParameters(ctx context.Context, in *BatchSetParametersRequest, opts ...grpc.CallOption) (*BatchSetParametersResponse, error)
	// ----- Flow Analysis Operations -----
	// Evaluate system flows using specified strategy
	EvaluateFlows(ctx context.Context, in *EvaluateFlowsRequest, opts ...grpc.CallOption) (*EvaluateFlowsResponse, error)
	// Get current flow state
	GetFlowState(ctx context.Context, in *GetFlowStateRequest, opts ...grpc.CallOption) (*GetFlowStateResponse, error)
	//	----- Generator Operations -----
	//
	// Adds a metric to live plot
	AddMetric(ctx context.Context, in *AddMetricRequest, opts ...grpc.CallOption) (*AddMetricResponse, error)
	// *
	// Delete a particular metriccanvas.  Frees up resources used by it and all the connections
	DeleteMetric(ctx context.Context, in *DeleteMetricRequest, opts ...grpc.CallOption) (*DeleteMetricResponse, error)
	// List all available metrics
	ListMetrics(ctx context.Context, in *ListMetricsRequest, opts ...grpc.CallOption) (*ListMetricsResponse, error)
	// Query raw metric data points
	QueryMetrics(ctx context.Context, in *QueryMetricsRequest, opts ...grpc.CallOption) (*QueryMetricsResponse, error)
	// Stream real-time metric updates
	StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamMetricsResponse], error)
	// Get the system diagram for visualization
	GetSystemDiagram(ctx context.Context, in *GetSystemDiagramRequest, opts ...grpc.CallOption) (*GetSystemDiagramResponse, error)
	// Get resource utilization information
	GetUtilization(ctx context.Context, in *GetUtilizationRequest, opts ...grpc.CallOption) (*GetUtilizationResponse, error)
}

type canvasServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCanvasServiceClient(cc grpc.ClientConnInterface) CanvasServiceClient {
	return &canvasServiceClient{cc}
}

func (c *canvasServiceClient) CreateCanvas(ctx context.Context, in *CreateCanvasRequest, opts ...grpc.CallOption) (*CreateCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_CreateCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ListCanvases(ctx context.Context, in *ListCanvasesRequest, opts ...grpc.CallOption) (*ListCanvasesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCanvasesResponse)
	err := c.cc.Invoke(ctx, CanvasService_ListCanvases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetCanvas(ctx context.Context, in *GetCanvasRequest, opts ...grpc.CallOption) (*GetCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) LoadFile(ctx context.Context, in *LoadFileRequest, opts ...grpc.CallOption) (*LoadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadFileResponse)
	err := c.cc.Invoke(ctx, CanvasService_LoadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) UseSystem(ctx context.Context, in *UseSystemRequest, opts ...grpc.CallOption) (*UseSystemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UseSystemResponse)
	err := c.cc.Invoke(ctx, CanvasService_UseSystem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteCanvas(ctx context.Context, in *DeleteCanvasRequest, opts ...grpc.CallOption) (*DeleteCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ResetCanvas(ctx context.Context, in *ResetCanvasRequest, opts ...grpc.CallOption) (*ResetCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_ResetCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) AddGenerator(ctx context.Context, in *AddGeneratorRequest, opts ...grpc.CallOption) (*AddGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_AddGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StartAllGenerators(ctx context.Context, in *StartAllGeneratorsRequest, opts ...grpc.CallOption) (*StartAllGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartAllGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_StartAllGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StopAllGenerators(ctx context.Context, in *StopAllGeneratorsRequest, opts ...grpc.CallOption) (*StopAllGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopAllGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_StopAllGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ListGenerators(ctx context.Context, in *ListGeneratorsRequest, opts ...grpc.CallOption) (*ListGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_ListGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetGenerator(ctx context.Context, in *GetGeneratorRequest, opts ...grpc.CallOption) (*GetGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) UpdateGenerator(ctx context.Context, in *UpdateGeneratorRequest, opts ...grpc.CallOption) (*UpdateGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_UpdateGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StopGenerator(ctx context.Context, in *StopGeneratorRequest, opts ...grpc.CallOption) (*StopGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_StopGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StartGenerator(ctx context.Context, in *StartGeneratorRequest, opts ...grpc.CallOption) (*StartGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_StartGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteGenerator(ctx context.Context, in *DeleteGeneratorRequest, opts ...grpc.CallOption) (*DeleteGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ExecuteTrace(ctx context.Context, in *ExecuteTraceRequest, opts ...grpc.CallOption) (*ExecuteTraceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteTraceResponse)
	err := c.cc.Invoke(ctx, CanvasService_ExecuteTrace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) TraceAllPaths(ctx context.Context, in *TraceAllPathsRequest, opts ...grpc.CallOption) (*TraceAllPathsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TraceAllPathsResponse)
	err := c.cc.Invoke(ctx, CanvasService_TraceAllPaths_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) SetParameter(ctx context.Context, in *SetParameterRequest, opts ...grpc.CallOption) (*SetParameterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetParameterResponse)
	err := c.cc.Invoke(ctx, CanvasService_SetParameter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetParameters(ctx context.Context, in *GetParametersRequest, opts ...grpc.CallOption) (*GetParametersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetParametersResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) BatchSetParameters(ctx context.Context, in *BatchSetParametersRequest, opts ...grpc.CallOption) (*BatchSetParametersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchSetParametersResponse)
	err := c.cc.Invoke(ctx, CanvasService_BatchSetParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) EvaluateFlows(ctx context.Context, in *EvaluateFlowsRequest, opts ...grpc.CallOption) (*EvaluateFlowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvaluateFlowsResponse)
	err := c.cc.Invoke(ctx, CanvasService_EvaluateFlows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetFlowState(ctx context.Context, in *GetFlowStateRequest, opts ...grpc.CallOption) (*GetFlowStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFlowStateResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetFlowState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) AddMetric(ctx context.Context, in *AddMetricRequest, opts ...grpc.CallOption) (*AddMetricResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddMetricResponse)
	err := c.cc.Invoke(ctx, CanvasService_AddMetric_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteMetric(ctx context.Context, in *DeleteMetricRequest, opts ...grpc.CallOption) (*DeleteMetricResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMetricResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteMetric_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ListMetrics(ctx context.Context, in *ListMetricsRequest, opts ...grpc.CallOption) (*ListMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMetricsResponse)
	err := c.cc.Invoke(ctx, CanvasService_ListMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) QueryMetrics(ctx context.Context, in *QueryMetricsRequest, opts ...grpc.CallOption) (*QueryMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryMetricsResponse)
	err := c.cc.Invoke(ctx, CanvasService_QueryMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamMetricsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CanvasService_ServiceDesc.Streams[0], CanvasService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsRequest, StreamMetricsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CanvasService_StreamMetricsClient = grpc.ServerStreamingClient[StreamMetricsResponse]

func (c *canvasServiceClient) GetSystemDiagram(ctx context.Context, in *GetSystemDiagramRequest, opts ...grpc.CallOption) (*GetSystemDiagramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSystemDiagramResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetSystemDiagram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetUtilization(ctx context.Context, in *GetUtilizationRequest, opts ...grpc.CallOption) (*GetUtilizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUtilizationResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetUtilization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CanvasServiceServer is the server API for CanvasService service.
// All implementations should embed UnimplementedCanvasServiceServer
// for forward compatibility.
//
// *
// Service for interacting with a canvas.
type CanvasServiceServer interface {
	// *
	// Create a new canvas sesssion.
	CreateCanvas(context.Context, *CreateCanvasRequest) (*CreateCanvasResponse, error)
	// *
	// List all canvases from a user.
	ListCanvases(context.Context, *ListCanvasesRequest) (*ListCanvasesResponse, error)
	// *
	// Get details/stats for a particular canvas
	GetCanvas(context.Context, *GetCanvasRequest) (*GetCanvasResponse, error)
	LoadFile(context.Context, *LoadFileRequest) (*LoadFileResponse, error)
	UseSystem(context.Context, *UseSystemRequest) (*UseSystemResponse, error)
	// *
	// Delete a particular canvas.  Frees up resources used by it and all the connections
	DeleteCanvas(context.Context, *DeleteCanvasRequest) (*DeleteCanvasResponse, error)
	// *
	// Reset a canvas - clears all state, generators, and metrics
	ResetCanvas(context.Context, *ResetCanvasRequest) (*ResetCanvasResponse, error)
	//	----- Generator Operations -----
	//
	// Adds a generator to a canvas's generator_ids list and creates the generator resource.
	AddGenerator(context.Context, *AddGeneratorRequest) (*AddGeneratorResponse, error)
	// Request to start all generators
	StartAllGenerators(context.Context, *StartAllGeneratorsRequest) (*StartAllGeneratorsResponse, error)
	// Request to start all generators
	StopAllGenerators(context.Context, *StopAllGeneratorsRequest) (*StopAllGeneratorsResponse, error)
	ListGenerators(context.Context, *ListGeneratorsRequest) (*ListGeneratorsResponse, error)
	GetGenerator(context.Context, *GetGeneratorRequest) (*GetGeneratorResponse, error)
	// Use PATCH for partial updates to a generator (title, content)
	UpdateGenerator(context.Context, *UpdateGeneratorRequest) (*UpdateGeneratorResponse, error)
	StopGenerator(context.Context, *StopGeneratorRequest) (*StopGeneratorResponse, error)
	StartGenerator(context.Context, *StartGeneratorRequest) (*StartGeneratorResponse, error)
	DeleteGenerator(context.Context, *DeleteGeneratorRequest) (*DeleteGeneratorResponse, error)
	// Execute a single trace for debugging/analysis
	ExecuteTrace(context.Context, *ExecuteTraceRequest) (*ExecuteTraceResponse, error)
	// Execute breadth-first traversal to find all possible execution paths
	TraceAllPaths(context.Context, *TraceAllPathsRequest) (*TraceAllPathsResponse, error)
	// ----- Parameter Operations -----
	// Set a component parameter value
	SetParameter(context.Context, *SetParameterRequest) (*SetParameterResponse, error)
	// Get parameter values
	GetParameters(context.Context, *GetParametersRequest) (*GetParametersResponse, error)
	// Batch set multiple parameters atomically
	BatchSetParameters(context.Context, *BatchSetParametersRequest) (*BatchSetParametersResponse, error)
	// ----- Flow Analysis Operations -----
	// Evaluate system flows using specified strategy
	EvaluateFlows(context.Context, *EvaluateFlowsRequest) (*EvaluateFlowsResponse, error)
	// Get current flow state
	GetFlowState(context.Context, *GetFlowStateRequest) (*GetFlowStateResponse, error)
	//	----- Generator Operations -----
	//
	// Adds a metric to live plot
	AddMetric(context.Context, *AddMetricRequest) (*AddMetricResponse, error)
	// *
	// Delete a particular metriccanvas.  Frees up resources used by it and all the connections
	DeleteMetric(context.Context, *DeleteMetricRequest) (*DeleteMetricResponse, error)
	// List all available metrics
	ListMetrics(context.Context, *ListMetricsRequest) (*ListMetricsResponse, error)
	// Query raw metric data points
	QueryMetrics(context.Context, *QueryMetricsRequest) (*QueryMetricsResponse, error)
	// Stream real-time metric updates
	StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[StreamMetricsResponse]) error
	// Get the system diagram for visualization
	GetSystemDiagram(context.Context, *GetSystemDiagramRequest) (*GetSystemDiagramResponse, error)
	// Get resource utilization information
	GetUtilization(context.Context, *GetUtilizationRequest) (*GetUtilizationResponse, error)
}

// UnimplementedCanvasServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCanvasServiceServer struct{}

func (UnimplementedCanvasServiceServer) CreateCanvas(context.Context, *CreateCanvasRequest) (*CreateCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) ListCanvases(context.Context, *ListCanvasesRequest) (*ListCanvasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCanvases not implemented")
}
func (UnimplementedCanvasServiceServer) GetCanvas(context.Context, *GetCanvasRequest) (*GetCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) LoadFile(context.Context, *LoadFileRequest) (*LoadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadFile not implemented")
}
func (UnimplementedCanvasServiceServer) UseSystem(context.Context, *UseSystemRequest) (*UseSystemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseSystem not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteCanvas(context.Context, *DeleteCanvasRequest) (*DeleteCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) ResetCanvas(context.Context, *ResetCanvasRequest) (*ResetCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) AddGenerator(context.Context, *AddGeneratorRequest) (*AddGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) StartAllGenerators(context.Context, *StartAllGeneratorsRequest) (*StartAllGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAllGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) StopAllGenerators(context.Context, *StopAllGeneratorsRequest) (*StopAllGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAllGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) ListGenerators(context.Context, *ListGeneratorsRequest) (*ListGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) GetGenerator(context.Context, *GetGeneratorRequest) (*GetGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) UpdateGenerator(context.Context, *UpdateGeneratorRequest) (*UpdateGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) StopGenerator(context.Context, *StopGeneratorRequest) (*StopGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) StartGenerator(context.Context, *StartGeneratorRequest) (*StartGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteGenerator(context.Context, *DeleteGeneratorRequest) (*DeleteGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) ExecuteTrace(context.Context, *ExecuteTraceRequest) (*ExecuteTraceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteTrace not implemented")
}
func (UnimplementedCanvasServiceServer) TraceAllPaths(context.Context, *TraceAllPathsRequest) (*TraceAllPathsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TraceAllPaths not implemented")
}
func (UnimplementedCanvasServiceServer) SetParameter(context.Context, *SetParameterRequest) (*SetParameterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetParameter not implemented")
}
func (UnimplementedCanvasServiceServer) GetParameters(context.Context, *GetParametersRequest) (*GetParametersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameters not implemented")
}
func (UnimplementedCanvasServiceServer) BatchSetParameters(context.Context, *BatchSetParametersRequest) (*BatchSetParametersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSetParameters not implemented")
}
func (UnimplementedCanvasServiceServer) EvaluateFlows(context.Context, *EvaluateFlowsRequest) (*EvaluateFlowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvaluateFlows not implemented")
}
func (UnimplementedCanvasServiceServer) GetFlowState(context.Context, *GetFlowStateRequest) (*GetFlowStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFlowState not implemented")
}
func (UnimplementedCanvasServiceServer) AddMetric(context.Context, *AddMetricRequest) (*AddMetricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMetric not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteMetric(context.Context, *DeleteMetricRequest) (*DeleteMetricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMetric not implemented")
}
func (UnimplementedCanvasServiceServer) ListMetrics(context.Context, *ListMetricsRequest) (*ListMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMetrics not implemented")
}
func (UnimplementedCanvasServiceServer) QueryMetrics(context.Context, *QueryMetricsRequest) (*QueryMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMetrics not implemented")
}
func (UnimplementedCanvasServiceServer) StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[StreamMetricsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedCanvasServiceServer) GetSystemDiagram(context.Context, *GetSystemDiagramRequest) (*GetSystemDiagramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemDiagram not implemented")
}
func (UnimplementedCanvasServiceServer) GetUtilization(context.Context, *GetUtilizationRequest) (*GetUtilizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUtilization not implemented")
}
func (UnimplementedCanvasServiceServer) testEmbeddedByValue() {}

// UnsafeCanvasServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CanvasServiceServer will
// result in compilation errors.
type UnsafeCanvasServiceServer interface {
	mustEmbedUnimplementedCanvasServiceServer()
}

func RegisterCanvasServiceServer(s grpc.ServiceRegistrar, srv CanvasServiceServer) {
	// If the following call pancis, it indicates UnimplementedCanvasServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CanvasService_ServiceDesc, srv)
}

func _CanvasService_CreateCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).CreateCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_CreateCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).CreateCanvas(ctx, req.(*CreateCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ListCanvases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCanvasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ListCanvases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ListCanvases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ListCanvases(ctx, req.(*ListCanvasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetCanvas(ctx, req.(*GetCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_LoadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).LoadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_LoadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).LoadFile(ctx, req.(*LoadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_UseSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UseSystemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).UseSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_UseSystem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).UseSystem(ctx, req.(*UseSystemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteCanvas(ctx, req.(*DeleteCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ResetCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ResetCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ResetCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ResetCanvas(ctx, req.(*ResetCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_AddGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).AddGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_AddGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).AddGenerator(ctx, req.(*AddGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StartAllGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAllGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StartAllGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StartAllGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StartAllGenerators(ctx, req.(*StartAllGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StopAllGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopAllGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StopAllGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StopAllGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StopAllGenerators(ctx, req.(*StopAllGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ListGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ListGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ListGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ListGenerators(ctx, req.(*ListGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetGenerator(ctx, req.(*GetGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_UpdateGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).UpdateGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_UpdateGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).UpdateGenerator(ctx, req.(*UpdateGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StopGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StopGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StopGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StopGenerator(ctx, req.(*StopGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StartGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StartGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StartGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StartGenerator(ctx, req.(*StartGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteGenerator(ctx, req.(*DeleteGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ExecuteTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ExecuteTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ExecuteTrace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ExecuteTrace(ctx, req.(*ExecuteTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_TraceAllPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TraceAllPathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).TraceAllPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_TraceAllPaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).TraceAllPaths(ctx, req.(*TraceAllPathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_SetParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetParameterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).SetParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_SetParameter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).SetParameter(ctx, req.(*SetParameterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetParametersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetParameters(ctx, req.(*GetParametersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_BatchSetParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSetParametersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).BatchSetParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_BatchSetParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).BatchSetParameters(ctx, req.(*BatchSetParametersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_EvaluateFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateFlowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).EvaluateFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_EvaluateFlows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).EvaluateFlows(ctx, req.(*EvaluateFlowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetFlowState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFlowStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetFlowState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetFlowState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetFlowState(ctx, req.(*GetFlowStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_AddMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMetricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).AddMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_AddMetric_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).AddMetric(ctx, req.(*AddMetricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMetricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteMetric_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteMetric(ctx, req.(*DeleteMetricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ListMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ListMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ListMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ListMetrics(ctx, req.(*ListMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_QueryMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).QueryMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_QueryMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).QueryMetrics(ctx, req.(*QueryMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CanvasServiceServer).StreamMetrics(m, &grpc.GenericServerStream[StreamMetricsRequest, StreamMetricsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CanvasService_StreamMetricsServer = grpc.ServerStreamingServer[StreamMetricsResponse]

func _CanvasService_GetSystemDiagram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemDiagramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetSystemDiagram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetSystemDiagram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetSystemDiagram(ctx, req.(*GetSystemDiagramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetUtilization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUtilizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetUtilization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetUtilization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetUtilization(ctx, req.(*GetUtilizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CanvasService_ServiceDesc is the grpc.ServiceDesc for CanvasService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CanvasService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sdl.v1.CanvasService",
	HandlerType: (*CanvasServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCanvas",
			Handler:    _CanvasService_CreateCanvas_Handler,
		},
		{
			MethodName: "ListCanvases",
			Handler:    _CanvasService_ListCanvases_Handler,
		},
		{
			MethodName: "GetCanvas",
			Handler:    _CanvasService_GetCanvas_Handler,
		},
		{
			MethodName: "LoadFile",
			Handler:    _CanvasService_LoadFile_Handler,
		},
		{
			MethodName: "UseSystem",
			Handler:    _CanvasService_UseSystem_Handler,
		},
		{
			MethodName: "DeleteCanvas",
			Handler:    _CanvasService_DeleteCanvas_Handler,
		},
		{
			MethodName: "ResetCanvas",
			Handler:    _CanvasService_ResetCanvas_Handler,
		},
		{
			MethodName: "AddGenerator",
			Handler:    _CanvasService_AddGenerator_Handler,
		},
		{
			MethodName: "StartAllGenerators",
			Handler:    _CanvasService_StartAllGenerators_Handler,
		},
		{
			MethodName: "StopAllGenerators",
			Handler:    _CanvasService_StopAllGenerators_Handler,
		},
		{
			MethodName: "ListGenerators",
			Handler:    _CanvasService_ListGenerators_Handler,
		},
		{
			MethodName: "GetGenerator",
			Handler:    _CanvasService_GetGenerator_Handler,
		},
		{
			MethodName: "UpdateGenerator",
			Handler:    _CanvasService_UpdateGenerator_Handler,
		},
		{
			MethodName: "StopGenerator",
			Handler:    _CanvasService_StopGenerator_Handler,
		},
		{
			MethodName: "StartGenerator",
			Handler:    _CanvasService_StartGenerator_Handler,
		},
		{
			MethodName: "DeleteGenerator",
			Handler:    _CanvasService_DeleteGenerator_Handler,
		},
		{
			MethodName: "ExecuteTrace",
			Handler:    _CanvasService_ExecuteTrace_Handler,
		},
		{
			MethodName: "TraceAllPaths",
			Handler:    _CanvasService_TraceAllPaths_Handler,
		},
		{
			MethodName: "SetParameter",
			Handler:    _CanvasService_SetParameter_Handler,
		},
		{
			MethodName: "GetParameters",
			Handler:    _CanvasService_GetParameters_Handler,
		},
		{
			MethodName: "BatchSetParameters",
			Handler:    _CanvasService_BatchSetParameters_Handler,
		},
		{
			MethodName: "EvaluateFlows",
			Handler:    _CanvasService_EvaluateFlows_Handler,
		},
		{
			MethodName: "GetFlowState",
			Handler:    _CanvasService_GetFlowState_Handler,
		},
		{
			MethodName: "AddMetric",
			Handler:    _CanvasService_AddMetric_Handler,
		},
		{
			MethodName: "DeleteMetric",
			Handler:    _CanvasService_DeleteMetric_Handler,
		},
		{
			MethodName: "ListMetrics",
			Handler:    _CanvasService_ListMetrics_Handler,
		},
		{
			MethodName: "QueryMetrics",
			Handler:    _CanvasService_QueryMetrics_Handler,
		},
		{
			MethodName: "GetSystemDiagram",
			Handler:    _CanvasService_GetSystemDiagram_Handler,
		},
		{
			MethodName: "GetUtilization",
			Handler:    _CanvasService_GetUtilization_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMetrics",
			Handler:       _CanvasService_StreamMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sdl/v1/canvas.proto",
}
