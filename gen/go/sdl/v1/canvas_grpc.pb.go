// protos/sdl/v1/canvas.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: sdl/v1/canvas.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CanvasService_CreateCanvas_FullMethodName       = "/sdl.v1.CanvasService/CreateCanvas"
	CanvasService_ListCanvases_FullMethodName       = "/sdl.v1.CanvasService/ListCanvases"
	CanvasService_GetCanvas_FullMethodName          = "/sdl.v1.CanvasService/GetCanvas"
	CanvasService_LoadFile_FullMethodName           = "/sdl.v1.CanvasService/LoadFile"
	CanvasService_UseSystem_FullMethodName          = "/sdl.v1.CanvasService/UseSystem"
	CanvasService_DeleteCanvas_FullMethodName       = "/sdl.v1.CanvasService/DeleteCanvas"
	CanvasService_AddGenerator_FullMethodName       = "/sdl.v1.CanvasService/AddGenerator"
	CanvasService_StartAllGenerators_FullMethodName = "/sdl.v1.CanvasService/StartAllGenerators"
	CanvasService_StopAllGenerators_FullMethodName  = "/sdl.v1.CanvasService/StopAllGenerators"
	CanvasService_GetGenerator_FullMethodName       = "/sdl.v1.CanvasService/GetGenerator"
	CanvasService_UpdateGenerator_FullMethodName    = "/sdl.v1.CanvasService/UpdateGenerator"
	CanvasService_PauseGenerator_FullMethodName     = "/sdl.v1.CanvasService/PauseGenerator"
	CanvasService_ResumeGenerator_FullMethodName    = "/sdl.v1.CanvasService/ResumeGenerator"
	CanvasService_DeleteGenerator_FullMethodName    = "/sdl.v1.CanvasService/DeleteGenerator"
)

// CanvasServiceClient is the client API for CanvasService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// *
// Service for interacting with a canvas.
type CanvasServiceClient interface {
	// *
	// Create a new canvas sesssion.
	CreateCanvas(ctx context.Context, in *CreateCanvasRequest, opts ...grpc.CallOption) (*CreateCanvasResponse, error)
	// *
	// List all canvases from a user.
	ListCanvases(ctx context.Context, in *ListCanvasesRequest, opts ...grpc.CallOption) (*ListCanvasesResponse, error)
	// *
	// Get details/stats for a particular canvas
	GetCanvas(ctx context.Context, in *GetCanvasRequest, opts ...grpc.CallOption) (*GetCanvasResponse, error)
	LoadFile(ctx context.Context, in *LoadFileRequest, opts ...grpc.CallOption) (*LoadFileResponse, error)
	UseSystem(ctx context.Context, in *UseSystemRequest, opts ...grpc.CallOption) (*UseSystemResponse, error)
	// *
	// Delete a particular canvas.  Frees up resources used by it and all the connections
	DeleteCanvas(ctx context.Context, in *DeleteCanvasRequest, opts ...grpc.CallOption) (*DeleteCanvasResponse, error)
	//	----- Generator Operations -----
	//
	// Adds a generator to a canvas's generator_ids list and creates the generator resource.
	AddGenerator(ctx context.Context, in *AddGeneratorRequest, opts ...grpc.CallOption) (*AddGeneratorResponse, error)
	// Request to start all generators
	StartAllGenerators(ctx context.Context, in *StartAllGeneratorsRequest, opts ...grpc.CallOption) (*StartAllGeneratorsResponse, error)
	// Request to start all generators
	StopAllGenerators(ctx context.Context, in *StopAllGeneratorsRequest, opts ...grpc.CallOption) (*StopAllGeneratorsResponse, error)
	GetGenerator(ctx context.Context, in *GetGeneratorRequest, opts ...grpc.CallOption) (*GetGeneratorResponse, error)
	// Use PATCH for partial updates to a generator (title, content)
	UpdateGenerator(ctx context.Context, in *UpdateGeneratorRequest, opts ...grpc.CallOption) (*UpdateGeneratorResponse, error)
	PauseGenerator(ctx context.Context, in *PauseGeneratorRequest, opts ...grpc.CallOption) (*PauseGeneratorResponse, error)
	ResumeGenerator(ctx context.Context, in *ResumeGeneratorRequest, opts ...grpc.CallOption) (*ResumeGeneratorResponse, error)
	DeleteGenerator(ctx context.Context, in *DeleteGeneratorRequest, opts ...grpc.CallOption) (*DeleteGeneratorResponse, error)
}

type canvasServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCanvasServiceClient(cc grpc.ClientConnInterface) CanvasServiceClient {
	return &canvasServiceClient{cc}
}

func (c *canvasServiceClient) CreateCanvas(ctx context.Context, in *CreateCanvasRequest, opts ...grpc.CallOption) (*CreateCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_CreateCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ListCanvases(ctx context.Context, in *ListCanvasesRequest, opts ...grpc.CallOption) (*ListCanvasesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCanvasesResponse)
	err := c.cc.Invoke(ctx, CanvasService_ListCanvases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetCanvas(ctx context.Context, in *GetCanvasRequest, opts ...grpc.CallOption) (*GetCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) LoadFile(ctx context.Context, in *LoadFileRequest, opts ...grpc.CallOption) (*LoadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadFileResponse)
	err := c.cc.Invoke(ctx, CanvasService_LoadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) UseSystem(ctx context.Context, in *UseSystemRequest, opts ...grpc.CallOption) (*UseSystemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UseSystemResponse)
	err := c.cc.Invoke(ctx, CanvasService_UseSystem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteCanvas(ctx context.Context, in *DeleteCanvasRequest, opts ...grpc.CallOption) (*DeleteCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) AddGenerator(ctx context.Context, in *AddGeneratorRequest, opts ...grpc.CallOption) (*AddGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_AddGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StartAllGenerators(ctx context.Context, in *StartAllGeneratorsRequest, opts ...grpc.CallOption) (*StartAllGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartAllGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_StartAllGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StopAllGenerators(ctx context.Context, in *StopAllGeneratorsRequest, opts ...grpc.CallOption) (*StopAllGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopAllGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_StopAllGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetGenerator(ctx context.Context, in *GetGeneratorRequest, opts ...grpc.CallOption) (*GetGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) UpdateGenerator(ctx context.Context, in *UpdateGeneratorRequest, opts ...grpc.CallOption) (*UpdateGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_UpdateGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) PauseGenerator(ctx context.Context, in *PauseGeneratorRequest, opts ...grpc.CallOption) (*PauseGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_PauseGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ResumeGenerator(ctx context.Context, in *ResumeGeneratorRequest, opts ...grpc.CallOption) (*ResumeGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_ResumeGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteGenerator(ctx context.Context, in *DeleteGeneratorRequest, opts ...grpc.CallOption) (*DeleteGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CanvasServiceServer is the server API for CanvasService service.
// All implementations should embed UnimplementedCanvasServiceServer
// for forward compatibility.
//
// *
// Service for interacting with a canvas.
type CanvasServiceServer interface {
	// *
	// Create a new canvas sesssion.
	CreateCanvas(context.Context, *CreateCanvasRequest) (*CreateCanvasResponse, error)
	// *
	// List all canvases from a user.
	ListCanvases(context.Context, *ListCanvasesRequest) (*ListCanvasesResponse, error)
	// *
	// Get details/stats for a particular canvas
	GetCanvas(context.Context, *GetCanvasRequest) (*GetCanvasResponse, error)
	LoadFile(context.Context, *LoadFileRequest) (*LoadFileResponse, error)
	UseSystem(context.Context, *UseSystemRequest) (*UseSystemResponse, error)
	// *
	// Delete a particular canvas.  Frees up resources used by it and all the connections
	DeleteCanvas(context.Context, *DeleteCanvasRequest) (*DeleteCanvasResponse, error)
	//	----- Generator Operations -----
	//
	// Adds a generator to a canvas's generator_ids list and creates the generator resource.
	AddGenerator(context.Context, *AddGeneratorRequest) (*AddGeneratorResponse, error)
	// Request to start all generators
	StartAllGenerators(context.Context, *StartAllGeneratorsRequest) (*StartAllGeneratorsResponse, error)
	// Request to start all generators
	StopAllGenerators(context.Context, *StopAllGeneratorsRequest) (*StopAllGeneratorsResponse, error)
	GetGenerator(context.Context, *GetGeneratorRequest) (*GetGeneratorResponse, error)
	// Use PATCH for partial updates to a generator (title, content)
	UpdateGenerator(context.Context, *UpdateGeneratorRequest) (*UpdateGeneratorResponse, error)
	PauseGenerator(context.Context, *PauseGeneratorRequest) (*PauseGeneratorResponse, error)
	ResumeGenerator(context.Context, *ResumeGeneratorRequest) (*ResumeGeneratorResponse, error)
	DeleteGenerator(context.Context, *DeleteGeneratorRequest) (*DeleteGeneratorResponse, error)
}

// UnimplementedCanvasServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCanvasServiceServer struct{}

func (UnimplementedCanvasServiceServer) CreateCanvas(context.Context, *CreateCanvasRequest) (*CreateCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) ListCanvases(context.Context, *ListCanvasesRequest) (*ListCanvasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCanvases not implemented")
}
func (UnimplementedCanvasServiceServer) GetCanvas(context.Context, *GetCanvasRequest) (*GetCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) LoadFile(context.Context, *LoadFileRequest) (*LoadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadFile not implemented")
}
func (UnimplementedCanvasServiceServer) UseSystem(context.Context, *UseSystemRequest) (*UseSystemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseSystem not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteCanvas(context.Context, *DeleteCanvasRequest) (*DeleteCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) AddGenerator(context.Context, *AddGeneratorRequest) (*AddGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) StartAllGenerators(context.Context, *StartAllGeneratorsRequest) (*StartAllGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAllGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) StopAllGenerators(context.Context, *StopAllGeneratorsRequest) (*StopAllGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAllGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) GetGenerator(context.Context, *GetGeneratorRequest) (*GetGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) UpdateGenerator(context.Context, *UpdateGeneratorRequest) (*UpdateGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) PauseGenerator(context.Context, *PauseGeneratorRequest) (*PauseGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) ResumeGenerator(context.Context, *ResumeGeneratorRequest) (*ResumeGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteGenerator(context.Context, *DeleteGeneratorRequest) (*DeleteGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) testEmbeddedByValue() {}

// UnsafeCanvasServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CanvasServiceServer will
// result in compilation errors.
type UnsafeCanvasServiceServer interface {
	mustEmbedUnimplementedCanvasServiceServer()
}

func RegisterCanvasServiceServer(s grpc.ServiceRegistrar, srv CanvasServiceServer) {
	// If the following call pancis, it indicates UnimplementedCanvasServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CanvasService_ServiceDesc, srv)
}

func _CanvasService_CreateCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).CreateCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_CreateCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).CreateCanvas(ctx, req.(*CreateCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ListCanvases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCanvasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ListCanvases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ListCanvases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ListCanvases(ctx, req.(*ListCanvasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetCanvas(ctx, req.(*GetCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_LoadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).LoadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_LoadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).LoadFile(ctx, req.(*LoadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_UseSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UseSystemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).UseSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_UseSystem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).UseSystem(ctx, req.(*UseSystemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteCanvas(ctx, req.(*DeleteCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_AddGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).AddGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_AddGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).AddGenerator(ctx, req.(*AddGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StartAllGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAllGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StartAllGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StartAllGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StartAllGenerators(ctx, req.(*StartAllGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StopAllGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopAllGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StopAllGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StopAllGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StopAllGenerators(ctx, req.(*StopAllGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetGenerator(ctx, req.(*GetGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_UpdateGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).UpdateGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_UpdateGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).UpdateGenerator(ctx, req.(*UpdateGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_PauseGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).PauseGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_PauseGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).PauseGenerator(ctx, req.(*PauseGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ResumeGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ResumeGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ResumeGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ResumeGenerator(ctx, req.(*ResumeGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteGenerator(ctx, req.(*DeleteGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CanvasService_ServiceDesc is the grpc.ServiceDesc for CanvasService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CanvasService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sdl.v1.CanvasService",
	HandlerType: (*CanvasServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCanvas",
			Handler:    _CanvasService_CreateCanvas_Handler,
		},
		{
			MethodName: "ListCanvases",
			Handler:    _CanvasService_ListCanvases_Handler,
		},
		{
			MethodName: "GetCanvas",
			Handler:    _CanvasService_GetCanvas_Handler,
		},
		{
			MethodName: "LoadFile",
			Handler:    _CanvasService_LoadFile_Handler,
		},
		{
			MethodName: "UseSystem",
			Handler:    _CanvasService_UseSystem_Handler,
		},
		{
			MethodName: "DeleteCanvas",
			Handler:    _CanvasService_DeleteCanvas_Handler,
		},
		{
			MethodName: "AddGenerator",
			Handler:    _CanvasService_AddGenerator_Handler,
		},
		{
			MethodName: "StartAllGenerators",
			Handler:    _CanvasService_StartAllGenerators_Handler,
		},
		{
			MethodName: "StopAllGenerators",
			Handler:    _CanvasService_StopAllGenerators_Handler,
		},
		{
			MethodName: "GetGenerator",
			Handler:    _CanvasService_GetGenerator_Handler,
		},
		{
			MethodName: "UpdateGenerator",
			Handler:    _CanvasService_UpdateGenerator_Handler,
		},
		{
			MethodName: "PauseGenerator",
			Handler:    _CanvasService_PauseGenerator_Handler,
		},
		{
			MethodName: "ResumeGenerator",
			Handler:    _CanvasService_ResumeGenerator_Handler,
		},
		{
			MethodName: "DeleteGenerator",
			Handler:    _CanvasService_DeleteGenerator_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdl/v1/canvas.proto",
}
