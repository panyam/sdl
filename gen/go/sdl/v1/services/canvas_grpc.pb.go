// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: sdl/v1/services/canvas.proto

package sdlv1

import (
	context "context"

	models "github.com/panyam/sdl/gen/go/sdl/v1/models"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CanvasService_CreateCanvas_FullMethodName       = "/sdl.v1.CanvasService/CreateCanvas"
	CanvasService_ListCanvases_FullMethodName       = "/sdl.v1.CanvasService/ListCanvases"
	CanvasService_GetCanvas_FullMethodName          = "/sdl.v1.CanvasService/GetCanvas"
	CanvasService_LoadFile_FullMethodName           = "/sdl.v1.CanvasService/LoadFile"
	CanvasService_UseSystem_FullMethodName          = "/sdl.v1.CanvasService/UseSystem"
	CanvasService_DeleteCanvas_FullMethodName       = "/sdl.v1.CanvasService/DeleteCanvas"
	CanvasService_ResetCanvas_FullMethodName        = "/sdl.v1.CanvasService/ResetCanvas"
	CanvasService_AddGenerator_FullMethodName       = "/sdl.v1.CanvasService/AddGenerator"
	CanvasService_StartAllGenerators_FullMethodName = "/sdl.v1.CanvasService/StartAllGenerators"
	CanvasService_StopAllGenerators_FullMethodName  = "/sdl.v1.CanvasService/StopAllGenerators"
	CanvasService_ListGenerators_FullMethodName     = "/sdl.v1.CanvasService/ListGenerators"
	CanvasService_GetGenerator_FullMethodName       = "/sdl.v1.CanvasService/GetGenerator"
	CanvasService_UpdateGenerator_FullMethodName    = "/sdl.v1.CanvasService/UpdateGenerator"
	CanvasService_StopGenerator_FullMethodName      = "/sdl.v1.CanvasService/StopGenerator"
	CanvasService_StartGenerator_FullMethodName     = "/sdl.v1.CanvasService/StartGenerator"
	CanvasService_DeleteGenerator_FullMethodName    = "/sdl.v1.CanvasService/DeleteGenerator"
	CanvasService_ExecuteTrace_FullMethodName       = "/sdl.v1.CanvasService/ExecuteTrace"
	CanvasService_TraceAllPaths_FullMethodName      = "/sdl.v1.CanvasService/TraceAllPaths"
	CanvasService_SetParameter_FullMethodName       = "/sdl.v1.CanvasService/SetParameter"
	CanvasService_GetParameters_FullMethodName      = "/sdl.v1.CanvasService/GetParameters"
	CanvasService_BatchSetParameters_FullMethodName = "/sdl.v1.CanvasService/BatchSetParameters"
	CanvasService_EvaluateFlows_FullMethodName      = "/sdl.v1.CanvasService/EvaluateFlows"
	CanvasService_GetFlowState_FullMethodName       = "/sdl.v1.CanvasService/GetFlowState"
	CanvasService_AddMetric_FullMethodName          = "/sdl.v1.CanvasService/AddMetric"
	CanvasService_DeleteMetric_FullMethodName       = "/sdl.v1.CanvasService/DeleteMetric"
	CanvasService_ListMetrics_FullMethodName        = "/sdl.v1.CanvasService/ListMetrics"
	CanvasService_QueryMetrics_FullMethodName       = "/sdl.v1.CanvasService/QueryMetrics"
	CanvasService_StreamMetrics_FullMethodName      = "/sdl.v1.CanvasService/StreamMetrics"
	CanvasService_GetSystemDiagram_FullMethodName   = "/sdl.v1.CanvasService/GetSystemDiagram"
	CanvasService_GetUtilization_FullMethodName     = "/sdl.v1.CanvasService/GetUtilization"
)

// CanvasServiceClient is the client API for CanvasService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for interacting with a canvas.
type CanvasServiceClient interface {
	// Create a new canvas sesssion.
	CreateCanvas(ctx context.Context, in *models.CreateCanvasRequest, opts ...grpc.CallOption) (*models.CreateCanvasResponse, error)
	// List all canvases from a user.
	ListCanvases(ctx context.Context, in *models.ListCanvasesRequest, opts ...grpc.CallOption) (*models.ListCanvasesResponse, error)
	// Get details/stats for a particular canvas
	GetCanvas(ctx context.Context, in *models.GetCanvasRequest, opts ...grpc.CallOption) (*models.GetCanvasResponse, error)
	LoadFile(ctx context.Context, in *models.LoadFileRequest, opts ...grpc.CallOption) (*models.LoadFileResponse, error)
	UseSystem(ctx context.Context, in *models.UseSystemRequest, opts ...grpc.CallOption) (*models.UseSystemResponse, error)
	// Delete a particular canvas. Frees up resources used by it and all the connections
	DeleteCanvas(ctx context.Context, in *models.DeleteCanvasRequest, opts ...grpc.CallOption) (*models.DeleteCanvasResponse, error)
	// Reset a canvas - clears all state, generators, and metrics
	ResetCanvas(ctx context.Context, in *models.ResetCanvasRequest, opts ...grpc.CallOption) (*models.ResetCanvasResponse, error)
	// Adds a generator to a canvas's generator_ids list and creates the generator resource.
	AddGenerator(ctx context.Context, in *models.AddGeneratorRequest, opts ...grpc.CallOption) (*models.AddGeneratorResponse, error)
	// Request to start all generators
	StartAllGenerators(ctx context.Context, in *models.StartAllGeneratorsRequest, opts ...grpc.CallOption) (*models.StartAllGeneratorsResponse, error)
	// Request to stop all generators
	StopAllGenerators(ctx context.Context, in *models.StopAllGeneratorsRequest, opts ...grpc.CallOption) (*models.StopAllGeneratorsResponse, error)
	ListGenerators(ctx context.Context, in *models.ListGeneratorsRequest, opts ...grpc.CallOption) (*models.ListGeneratorsResponse, error)
	GetGenerator(ctx context.Context, in *models.GetGeneratorRequest, opts ...grpc.CallOption) (*models.GetGeneratorResponse, error)
	// Use PATCH for partial updates to a generator
	UpdateGenerator(ctx context.Context, in *models.UpdateGeneratorRequest, opts ...grpc.CallOption) (*models.UpdateGeneratorResponse, error)
	StopGenerator(ctx context.Context, in *models.StopGeneratorRequest, opts ...grpc.CallOption) (*models.StopGeneratorResponse, error)
	StartGenerator(ctx context.Context, in *models.StartGeneratorRequest, opts ...grpc.CallOption) (*models.StartGeneratorResponse, error)
	DeleteGenerator(ctx context.Context, in *models.DeleteGeneratorRequest, opts ...grpc.CallOption) (*models.DeleteGeneratorResponse, error)
	// Execute a single trace for debugging/analysis
	ExecuteTrace(ctx context.Context, in *models.ExecuteTraceRequest, opts ...grpc.CallOption) (*models.ExecuteTraceResponse, error)
	// Execute breadth-first traversal to find all possible execution paths
	TraceAllPaths(ctx context.Context, in *models.TraceAllPathsRequest, opts ...grpc.CallOption) (*models.TraceAllPathsResponse, error)
	// Set a component parameter value
	SetParameter(ctx context.Context, in *models.SetParameterRequest, opts ...grpc.CallOption) (*models.SetParameterResponse, error)
	// Get parameter values
	GetParameters(ctx context.Context, in *models.GetParametersRequest, opts ...grpc.CallOption) (*models.GetParametersResponse, error)
	// Batch set multiple parameters atomically
	BatchSetParameters(ctx context.Context, in *models.BatchSetParametersRequest, opts ...grpc.CallOption) (*models.BatchSetParametersResponse, error)
	// Evaluate system flows using specified strategy
	EvaluateFlows(ctx context.Context, in *models.EvaluateFlowsRequest, opts ...grpc.CallOption) (*models.EvaluateFlowsResponse, error)
	// Get current flow state
	GetFlowState(ctx context.Context, in *models.GetFlowStateRequest, opts ...grpc.CallOption) (*models.GetFlowStateResponse, error)
	// Adds a metric to live plot
	AddMetric(ctx context.Context, in *models.AddMetricRequest, opts ...grpc.CallOption) (*models.AddMetricResponse, error)
	// Delete a particular metric
	DeleteMetric(ctx context.Context, in *models.DeleteMetricRequest, opts ...grpc.CallOption) (*models.DeleteMetricResponse, error)
	// List all available metrics
	ListMetrics(ctx context.Context, in *models.ListMetricsRequest, opts ...grpc.CallOption) (*models.ListMetricsResponse, error)
	// Query raw metric data points
	QueryMetrics(ctx context.Context, in *models.QueryMetricsRequest, opts ...grpc.CallOption) (*models.QueryMetricsResponse, error)
	// Stream real-time metric updates
	StreamMetrics(ctx context.Context, in *models.StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[models.StreamMetricsResponse], error)
	// Get the system diagram for visualization
	GetSystemDiagram(ctx context.Context, in *models.GetSystemDiagramRequest, opts ...grpc.CallOption) (*models.GetSystemDiagramResponse, error)
	// Get resource utilization information
	GetUtilization(ctx context.Context, in *models.GetUtilizationRequest, opts ...grpc.CallOption) (*models.GetUtilizationResponse, error)
}

type canvasServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCanvasServiceClient(cc grpc.ClientConnInterface) CanvasServiceClient {
	return &canvasServiceClient{cc}
}

func (c *canvasServiceClient) CreateCanvas(ctx context.Context, in *models.CreateCanvasRequest, opts ...grpc.CallOption) (*models.CreateCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.CreateCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_CreateCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ListCanvases(ctx context.Context, in *models.ListCanvasesRequest, opts ...grpc.CallOption) (*models.ListCanvasesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.ListCanvasesResponse)
	err := c.cc.Invoke(ctx, CanvasService_ListCanvases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetCanvas(ctx context.Context, in *models.GetCanvasRequest, opts ...grpc.CallOption) (*models.GetCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) LoadFile(ctx context.Context, in *models.LoadFileRequest, opts ...grpc.CallOption) (*models.LoadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.LoadFileResponse)
	err := c.cc.Invoke(ctx, CanvasService_LoadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) UseSystem(ctx context.Context, in *models.UseSystemRequest, opts ...grpc.CallOption) (*models.UseSystemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.UseSystemResponse)
	err := c.cc.Invoke(ctx, CanvasService_UseSystem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteCanvas(ctx context.Context, in *models.DeleteCanvasRequest, opts ...grpc.CallOption) (*models.DeleteCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.DeleteCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ResetCanvas(ctx context.Context, in *models.ResetCanvasRequest, opts ...grpc.CallOption) (*models.ResetCanvasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.ResetCanvasResponse)
	err := c.cc.Invoke(ctx, CanvasService_ResetCanvas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) AddGenerator(ctx context.Context, in *models.AddGeneratorRequest, opts ...grpc.CallOption) (*models.AddGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.AddGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_AddGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StartAllGenerators(ctx context.Context, in *models.StartAllGeneratorsRequest, opts ...grpc.CallOption) (*models.StartAllGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.StartAllGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_StartAllGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StopAllGenerators(ctx context.Context, in *models.StopAllGeneratorsRequest, opts ...grpc.CallOption) (*models.StopAllGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.StopAllGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_StopAllGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ListGenerators(ctx context.Context, in *models.ListGeneratorsRequest, opts ...grpc.CallOption) (*models.ListGeneratorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.ListGeneratorsResponse)
	err := c.cc.Invoke(ctx, CanvasService_ListGenerators_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetGenerator(ctx context.Context, in *models.GetGeneratorRequest, opts ...grpc.CallOption) (*models.GetGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) UpdateGenerator(ctx context.Context, in *models.UpdateGeneratorRequest, opts ...grpc.CallOption) (*models.UpdateGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.UpdateGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_UpdateGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StopGenerator(ctx context.Context, in *models.StopGeneratorRequest, opts ...grpc.CallOption) (*models.StopGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.StopGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_StopGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StartGenerator(ctx context.Context, in *models.StartGeneratorRequest, opts ...grpc.CallOption) (*models.StartGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.StartGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_StartGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteGenerator(ctx context.Context, in *models.DeleteGeneratorRequest, opts ...grpc.CallOption) (*models.DeleteGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.DeleteGeneratorResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ExecuteTrace(ctx context.Context, in *models.ExecuteTraceRequest, opts ...grpc.CallOption) (*models.ExecuteTraceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.ExecuteTraceResponse)
	err := c.cc.Invoke(ctx, CanvasService_ExecuteTrace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) TraceAllPaths(ctx context.Context, in *models.TraceAllPathsRequest, opts ...grpc.CallOption) (*models.TraceAllPathsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.TraceAllPathsResponse)
	err := c.cc.Invoke(ctx, CanvasService_TraceAllPaths_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) SetParameter(ctx context.Context, in *models.SetParameterRequest, opts ...grpc.CallOption) (*models.SetParameterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.SetParameterResponse)
	err := c.cc.Invoke(ctx, CanvasService_SetParameter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetParameters(ctx context.Context, in *models.GetParametersRequest, opts ...grpc.CallOption) (*models.GetParametersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetParametersResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) BatchSetParameters(ctx context.Context, in *models.BatchSetParametersRequest, opts ...grpc.CallOption) (*models.BatchSetParametersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.BatchSetParametersResponse)
	err := c.cc.Invoke(ctx, CanvasService_BatchSetParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) EvaluateFlows(ctx context.Context, in *models.EvaluateFlowsRequest, opts ...grpc.CallOption) (*models.EvaluateFlowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.EvaluateFlowsResponse)
	err := c.cc.Invoke(ctx, CanvasService_EvaluateFlows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetFlowState(ctx context.Context, in *models.GetFlowStateRequest, opts ...grpc.CallOption) (*models.GetFlowStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetFlowStateResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetFlowState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) AddMetric(ctx context.Context, in *models.AddMetricRequest, opts ...grpc.CallOption) (*models.AddMetricResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.AddMetricResponse)
	err := c.cc.Invoke(ctx, CanvasService_AddMetric_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) DeleteMetric(ctx context.Context, in *models.DeleteMetricRequest, opts ...grpc.CallOption) (*models.DeleteMetricResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.DeleteMetricResponse)
	err := c.cc.Invoke(ctx, CanvasService_DeleteMetric_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) ListMetrics(ctx context.Context, in *models.ListMetricsRequest, opts ...grpc.CallOption) (*models.ListMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.ListMetricsResponse)
	err := c.cc.Invoke(ctx, CanvasService_ListMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) QueryMetrics(ctx context.Context, in *models.QueryMetricsRequest, opts ...grpc.CallOption) (*models.QueryMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.QueryMetricsResponse)
	err := c.cc.Invoke(ctx, CanvasService_QueryMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) StreamMetrics(ctx context.Context, in *models.StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[models.StreamMetricsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CanvasService_ServiceDesc.Streams[0], CanvasService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[models.StreamMetricsRequest, models.StreamMetricsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CanvasService_StreamMetricsClient = grpc.ServerStreamingClient[models.StreamMetricsResponse]

func (c *canvasServiceClient) GetSystemDiagram(ctx context.Context, in *models.GetSystemDiagramRequest, opts ...grpc.CallOption) (*models.GetSystemDiagramResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetSystemDiagramResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetSystemDiagram_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canvasServiceClient) GetUtilization(ctx context.Context, in *models.GetUtilizationRequest, opts ...grpc.CallOption) (*models.GetUtilizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(models.GetUtilizationResponse)
	err := c.cc.Invoke(ctx, CanvasService_GetUtilization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CanvasServiceServer is the server API for CanvasService service.
// All implementations should embed UnimplementedCanvasServiceServer
// for forward compatibility.
//
// Service for interacting with a canvas.
type CanvasServiceServer interface {
	// Create a new canvas sesssion.
	CreateCanvas(context.Context, *models.CreateCanvasRequest) (*models.CreateCanvasResponse, error)
	// List all canvases from a user.
	ListCanvases(context.Context, *models.ListCanvasesRequest) (*models.ListCanvasesResponse, error)
	// Get details/stats for a particular canvas
	GetCanvas(context.Context, *models.GetCanvasRequest) (*models.GetCanvasResponse, error)
	LoadFile(context.Context, *models.LoadFileRequest) (*models.LoadFileResponse, error)
	UseSystem(context.Context, *models.UseSystemRequest) (*models.UseSystemResponse, error)
	// Delete a particular canvas. Frees up resources used by it and all the connections
	DeleteCanvas(context.Context, *models.DeleteCanvasRequest) (*models.DeleteCanvasResponse, error)
	// Reset a canvas - clears all state, generators, and metrics
	ResetCanvas(context.Context, *models.ResetCanvasRequest) (*models.ResetCanvasResponse, error)
	// Adds a generator to a canvas's generator_ids list and creates the generator resource.
	AddGenerator(context.Context, *models.AddGeneratorRequest) (*models.AddGeneratorResponse, error)
	// Request to start all generators
	StartAllGenerators(context.Context, *models.StartAllGeneratorsRequest) (*models.StartAllGeneratorsResponse, error)
	// Request to stop all generators
	StopAllGenerators(context.Context, *models.StopAllGeneratorsRequest) (*models.StopAllGeneratorsResponse, error)
	ListGenerators(context.Context, *models.ListGeneratorsRequest) (*models.ListGeneratorsResponse, error)
	GetGenerator(context.Context, *models.GetGeneratorRequest) (*models.GetGeneratorResponse, error)
	// Use PATCH for partial updates to a generator
	UpdateGenerator(context.Context, *models.UpdateGeneratorRequest) (*models.UpdateGeneratorResponse, error)
	StopGenerator(context.Context, *models.StopGeneratorRequest) (*models.StopGeneratorResponse, error)
	StartGenerator(context.Context, *models.StartGeneratorRequest) (*models.StartGeneratorResponse, error)
	DeleteGenerator(context.Context, *models.DeleteGeneratorRequest) (*models.DeleteGeneratorResponse, error)
	// Execute a single trace for debugging/analysis
	ExecuteTrace(context.Context, *models.ExecuteTraceRequest) (*models.ExecuteTraceResponse, error)
	// Execute breadth-first traversal to find all possible execution paths
	TraceAllPaths(context.Context, *models.TraceAllPathsRequest) (*models.TraceAllPathsResponse, error)
	// Set a component parameter value
	SetParameter(context.Context, *models.SetParameterRequest) (*models.SetParameterResponse, error)
	// Get parameter values
	GetParameters(context.Context, *models.GetParametersRequest) (*models.GetParametersResponse, error)
	// Batch set multiple parameters atomically
	BatchSetParameters(context.Context, *models.BatchSetParametersRequest) (*models.BatchSetParametersResponse, error)
	// Evaluate system flows using specified strategy
	EvaluateFlows(context.Context, *models.EvaluateFlowsRequest) (*models.EvaluateFlowsResponse, error)
	// Get current flow state
	GetFlowState(context.Context, *models.GetFlowStateRequest) (*models.GetFlowStateResponse, error)
	// Adds a metric to live plot
	AddMetric(context.Context, *models.AddMetricRequest) (*models.AddMetricResponse, error)
	// Delete a particular metric
	DeleteMetric(context.Context, *models.DeleteMetricRequest) (*models.DeleteMetricResponse, error)
	// List all available metrics
	ListMetrics(context.Context, *models.ListMetricsRequest) (*models.ListMetricsResponse, error)
	// Query raw metric data points
	QueryMetrics(context.Context, *models.QueryMetricsRequest) (*models.QueryMetricsResponse, error)
	// Stream real-time metric updates
	StreamMetrics(*models.StreamMetricsRequest, grpc.ServerStreamingServer[models.StreamMetricsResponse]) error
	// Get the system diagram for visualization
	GetSystemDiagram(context.Context, *models.GetSystemDiagramRequest) (*models.GetSystemDiagramResponse, error)
	// Get resource utilization information
	GetUtilization(context.Context, *models.GetUtilizationRequest) (*models.GetUtilizationResponse, error)
}

// UnimplementedCanvasServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCanvasServiceServer struct{}

func (UnimplementedCanvasServiceServer) CreateCanvas(context.Context, *models.CreateCanvasRequest) (*models.CreateCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) ListCanvases(context.Context, *models.ListCanvasesRequest) (*models.ListCanvasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCanvases not implemented")
}
func (UnimplementedCanvasServiceServer) GetCanvas(context.Context, *models.GetCanvasRequest) (*models.GetCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) LoadFile(context.Context, *models.LoadFileRequest) (*models.LoadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadFile not implemented")
}
func (UnimplementedCanvasServiceServer) UseSystem(context.Context, *models.UseSystemRequest) (*models.UseSystemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseSystem not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteCanvas(context.Context, *models.DeleteCanvasRequest) (*models.DeleteCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) ResetCanvas(context.Context, *models.ResetCanvasRequest) (*models.ResetCanvasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetCanvas not implemented")
}
func (UnimplementedCanvasServiceServer) AddGenerator(context.Context, *models.AddGeneratorRequest) (*models.AddGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) StartAllGenerators(context.Context, *models.StartAllGeneratorsRequest) (*models.StartAllGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAllGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) StopAllGenerators(context.Context, *models.StopAllGeneratorsRequest) (*models.StopAllGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAllGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) ListGenerators(context.Context, *models.ListGeneratorsRequest) (*models.ListGeneratorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGenerators not implemented")
}
func (UnimplementedCanvasServiceServer) GetGenerator(context.Context, *models.GetGeneratorRequest) (*models.GetGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) UpdateGenerator(context.Context, *models.UpdateGeneratorRequest) (*models.UpdateGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) StopGenerator(context.Context, *models.StopGeneratorRequest) (*models.StopGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) StartGenerator(context.Context, *models.StartGeneratorRequest) (*models.StartGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteGenerator(context.Context, *models.DeleteGeneratorRequest) (*models.DeleteGeneratorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGenerator not implemented")
}
func (UnimplementedCanvasServiceServer) ExecuteTrace(context.Context, *models.ExecuteTraceRequest) (*models.ExecuteTraceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteTrace not implemented")
}
func (UnimplementedCanvasServiceServer) TraceAllPaths(context.Context, *models.TraceAllPathsRequest) (*models.TraceAllPathsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TraceAllPaths not implemented")
}
func (UnimplementedCanvasServiceServer) SetParameter(context.Context, *models.SetParameterRequest) (*models.SetParameterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetParameter not implemented")
}
func (UnimplementedCanvasServiceServer) GetParameters(context.Context, *models.GetParametersRequest) (*models.GetParametersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameters not implemented")
}
func (UnimplementedCanvasServiceServer) BatchSetParameters(context.Context, *models.BatchSetParametersRequest) (*models.BatchSetParametersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSetParameters not implemented")
}
func (UnimplementedCanvasServiceServer) EvaluateFlows(context.Context, *models.EvaluateFlowsRequest) (*models.EvaluateFlowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvaluateFlows not implemented")
}
func (UnimplementedCanvasServiceServer) GetFlowState(context.Context, *models.GetFlowStateRequest) (*models.GetFlowStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFlowState not implemented")
}
func (UnimplementedCanvasServiceServer) AddMetric(context.Context, *models.AddMetricRequest) (*models.AddMetricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMetric not implemented")
}
func (UnimplementedCanvasServiceServer) DeleteMetric(context.Context, *models.DeleteMetricRequest) (*models.DeleteMetricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMetric not implemented")
}
func (UnimplementedCanvasServiceServer) ListMetrics(context.Context, *models.ListMetricsRequest) (*models.ListMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMetrics not implemented")
}
func (UnimplementedCanvasServiceServer) QueryMetrics(context.Context, *models.QueryMetricsRequest) (*models.QueryMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMetrics not implemented")
}
func (UnimplementedCanvasServiceServer) StreamMetrics(*models.StreamMetricsRequest, grpc.ServerStreamingServer[models.StreamMetricsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedCanvasServiceServer) GetSystemDiagram(context.Context, *models.GetSystemDiagramRequest) (*models.GetSystemDiagramResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemDiagram not implemented")
}
func (UnimplementedCanvasServiceServer) GetUtilization(context.Context, *models.GetUtilizationRequest) (*models.GetUtilizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUtilization not implemented")
}
func (UnimplementedCanvasServiceServer) testEmbeddedByValue() {}

// UnsafeCanvasServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CanvasServiceServer will
// result in compilation errors.
type UnsafeCanvasServiceServer interface {
	mustEmbedUnimplementedCanvasServiceServer()
}

func RegisterCanvasServiceServer(s grpc.ServiceRegistrar, srv CanvasServiceServer) {
	// If the following call pancis, it indicates UnimplementedCanvasServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CanvasService_ServiceDesc, srv)
}

func _CanvasService_CreateCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.CreateCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).CreateCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_CreateCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).CreateCanvas(ctx, req.(*models.CreateCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ListCanvases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.ListCanvasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ListCanvases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ListCanvases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ListCanvases(ctx, req.(*models.ListCanvasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetCanvas(ctx, req.(*models.GetCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_LoadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.LoadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).LoadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_LoadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).LoadFile(ctx, req.(*models.LoadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_UseSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.UseSystemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).UseSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_UseSystem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).UseSystem(ctx, req.(*models.UseSystemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.DeleteCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteCanvas(ctx, req.(*models.DeleteCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ResetCanvas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.ResetCanvasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ResetCanvas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ResetCanvas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ResetCanvas(ctx, req.(*models.ResetCanvasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_AddGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.AddGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).AddGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_AddGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).AddGenerator(ctx, req.(*models.AddGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StartAllGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.StartAllGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StartAllGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StartAllGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StartAllGenerators(ctx, req.(*models.StartAllGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StopAllGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.StopAllGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StopAllGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StopAllGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StopAllGenerators(ctx, req.(*models.StopAllGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ListGenerators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.ListGeneratorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ListGenerators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ListGenerators_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ListGenerators(ctx, req.(*models.ListGeneratorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetGenerator(ctx, req.(*models.GetGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_UpdateGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.UpdateGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).UpdateGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_UpdateGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).UpdateGenerator(ctx, req.(*models.UpdateGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StopGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.StopGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StopGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StopGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StopGenerator(ctx, req.(*models.StopGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StartGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.StartGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).StartGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_StartGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).StartGenerator(ctx, req.(*models.StartGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.DeleteGeneratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteGenerator(ctx, req.(*models.DeleteGeneratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ExecuteTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.ExecuteTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ExecuteTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ExecuteTrace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ExecuteTrace(ctx, req.(*models.ExecuteTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_TraceAllPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.TraceAllPathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).TraceAllPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_TraceAllPaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).TraceAllPaths(ctx, req.(*models.TraceAllPathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_SetParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.SetParameterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).SetParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_SetParameter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).SetParameter(ctx, req.(*models.SetParameterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetParametersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetParameters(ctx, req.(*models.GetParametersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_BatchSetParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.BatchSetParametersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).BatchSetParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_BatchSetParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).BatchSetParameters(ctx, req.(*models.BatchSetParametersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_EvaluateFlows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.EvaluateFlowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).EvaluateFlows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_EvaluateFlows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).EvaluateFlows(ctx, req.(*models.EvaluateFlowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetFlowState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetFlowStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetFlowState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetFlowState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetFlowState(ctx, req.(*models.GetFlowStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_AddMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.AddMetricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).AddMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_AddMetric_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).AddMetric(ctx, req.(*models.AddMetricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_DeleteMetric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.DeleteMetricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).DeleteMetric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_DeleteMetric_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).DeleteMetric(ctx, req.(*models.DeleteMetricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_ListMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.ListMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).ListMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_ListMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).ListMetrics(ctx, req.(*models.ListMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_QueryMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.QueryMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).QueryMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_QueryMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).QueryMetrics(ctx, req.(*models.QueryMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(models.StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CanvasServiceServer).StreamMetrics(m, &grpc.GenericServerStream[models.StreamMetricsRequest, models.StreamMetricsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CanvasService_StreamMetricsServer = grpc.ServerStreamingServer[models.StreamMetricsResponse]

func _CanvasService_GetSystemDiagram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetSystemDiagramRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetSystemDiagram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetSystemDiagram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetSystemDiagram(ctx, req.(*models.GetSystemDiagramRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanvasService_GetUtilization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(models.GetUtilizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanvasServiceServer).GetUtilization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanvasService_GetUtilization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanvasServiceServer).GetUtilization(ctx, req.(*models.GetUtilizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CanvasService_ServiceDesc is the grpc.ServiceDesc for CanvasService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CanvasService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sdl.v1.CanvasService",
	HandlerType: (*CanvasServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCanvas",
			Handler:    _CanvasService_CreateCanvas_Handler,
		},
		{
			MethodName: "ListCanvases",
			Handler:    _CanvasService_ListCanvases_Handler,
		},
		{
			MethodName: "GetCanvas",
			Handler:    _CanvasService_GetCanvas_Handler,
		},
		{
			MethodName: "LoadFile",
			Handler:    _CanvasService_LoadFile_Handler,
		},
		{
			MethodName: "UseSystem",
			Handler:    _CanvasService_UseSystem_Handler,
		},
		{
			MethodName: "DeleteCanvas",
			Handler:    _CanvasService_DeleteCanvas_Handler,
		},
		{
			MethodName: "ResetCanvas",
			Handler:    _CanvasService_ResetCanvas_Handler,
		},
		{
			MethodName: "AddGenerator",
			Handler:    _CanvasService_AddGenerator_Handler,
		},
		{
			MethodName: "StartAllGenerators",
			Handler:    _CanvasService_StartAllGenerators_Handler,
		},
		{
			MethodName: "StopAllGenerators",
			Handler:    _CanvasService_StopAllGenerators_Handler,
		},
		{
			MethodName: "ListGenerators",
			Handler:    _CanvasService_ListGenerators_Handler,
		},
		{
			MethodName: "GetGenerator",
			Handler:    _CanvasService_GetGenerator_Handler,
		},
		{
			MethodName: "UpdateGenerator",
			Handler:    _CanvasService_UpdateGenerator_Handler,
		},
		{
			MethodName: "StopGenerator",
			Handler:    _CanvasService_StopGenerator_Handler,
		},
		{
			MethodName: "StartGenerator",
			Handler:    _CanvasService_StartGenerator_Handler,
		},
		{
			MethodName: "DeleteGenerator",
			Handler:    _CanvasService_DeleteGenerator_Handler,
		},
		{
			MethodName: "ExecuteTrace",
			Handler:    _CanvasService_ExecuteTrace_Handler,
		},
		{
			MethodName: "TraceAllPaths",
			Handler:    _CanvasService_TraceAllPaths_Handler,
		},
		{
			MethodName: "SetParameter",
			Handler:    _CanvasService_SetParameter_Handler,
		},
		{
			MethodName: "GetParameters",
			Handler:    _CanvasService_GetParameters_Handler,
		},
		{
			MethodName: "BatchSetParameters",
			Handler:    _CanvasService_BatchSetParameters_Handler,
		},
		{
			MethodName: "EvaluateFlows",
			Handler:    _CanvasService_EvaluateFlows_Handler,
		},
		{
			MethodName: "GetFlowState",
			Handler:    _CanvasService_GetFlowState_Handler,
		},
		{
			MethodName: "AddMetric",
			Handler:    _CanvasService_AddMetric_Handler,
		},
		{
			MethodName: "DeleteMetric",
			Handler:    _CanvasService_DeleteMetric_Handler,
		},
		{
			MethodName: "ListMetrics",
			Handler:    _CanvasService_ListMetrics_Handler,
		},
		{
			MethodName: "QueryMetrics",
			Handler:    _CanvasService_QueryMetrics_Handler,
		},
		{
			MethodName: "GetSystemDiagram",
			Handler:    _CanvasService_GetSystemDiagram_Handler,
		},
		{
			MethodName: "GetUtilization",
			Handler:    _CanvasService_GetUtilization_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMetrics",
			Handler:       _CanvasService_StreamMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sdl/v1/services/canvas.proto",
}
