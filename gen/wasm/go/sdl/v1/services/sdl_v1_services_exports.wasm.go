//go:build js && wasm
// +build js,wasm

// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: sdl/v1/services/canvas.proto

package sdl

import (
	"context"
	"encoding/json"
	"fmt"
	"syscall/js"
	"time"

	wasm "github.com/panyam/protoc-gen-go-wasmjs/pkg/wasm"
	v1models "github.com/panyam/sdl/gen/go/sdl/v1/models"
)

// Sdl_v1ServicesExports provides WASM exports for dependency injection
type Sdl_v1ServicesExports struct {
	CanvasService               CanvasServiceServer
	SingletonInitializerService SingletonInitializerServiceServer
	CanvasViewPresenter         CanvasViewPresenterServer
	SystemsService              SystemsServiceServer

	// Browser-provided services (clients)
	CanvasDashboardPage *CanvasDashboardPageClient
}

// RegisterAPI registers the services with the JavaScript global namespace
func (exports *Sdl_v1ServicesExports) RegisterAPI() {
	fmt.Println("sdl WASM module loading...")

	// Initialize browser channel for browser-provided services
	_ = wasm.GetBrowserChannel()
	// Create namespaced API structure
	sdl := map[string]interface{}{
		"canvasService": map[string]interface{}{
			"createCanvas": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceCreateCanvas(this, args)
			}),
			"updateCanvas": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceUpdateCanvas(this, args)
			}),
			"listCanvases": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceListCanvases(this, args)
			}),
			"getCanvas": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceGetCanvas(this, args)
			}),
			"loadFile": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceLoadFile(this, args)
			}),
			"useSystem": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceUseSystem(this, args)
			}),
			"deleteCanvas": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceDeleteCanvas(this, args)
			}),
			"resetCanvas": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceResetCanvas(this, args)
			}),
			"addGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceAddGenerator(this, args)
			}),
			"startAllGenerators": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceStartAllGenerators(this, args)
			}),
			"stopAllGenerators": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceStopAllGenerators(this, args)
			}),
			"listGenerators": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceListGenerators(this, args)
			}),
			"getGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceGetGenerator(this, args)
			}),
			"updateGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceUpdateGenerator(this, args)
			}),
			"stopGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceStopGenerator(this, args)
			}),
			"startGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceStartGenerator(this, args)
			}),
			"deleteGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceDeleteGenerator(this, args)
			}),
			"executeTrace": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceExecuteTrace(this, args)
			}),
			"traceAllPaths": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceTraceAllPaths(this, args)
			}),
			"setParameter": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceSetParameter(this, args)
			}),
			"getParameters": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceGetParameters(this, args)
			}),
			"batchSetParameters": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceBatchSetParameters(this, args)
			}),
			"evaluateFlows": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceEvaluateFlows(this, args)
			}),
			"getFlowState": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceGetFlowState(this, args)
			}),
			"addMetric": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceAddMetric(this, args)
			}),
			"deleteMetric": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceDeleteMetric(this, args)
			}),
			"listMetrics": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceListMetrics(this, args)
			}),
			"queryMetrics": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceQueryMetrics(this, args)
			}),
			"streamMetrics": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceStreamMetrics(this, args)
			}),
			"getSystemDiagram": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceGetSystemDiagram(this, args)
			}),
			"getUtilization": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasServiceGetUtilization(this, args)
			}),
		},
		"singletonInitializerService": map[string]interface{}{
			"initializeSingleton": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.singletonInitializerServiceInitializeSingleton(this, args)
			}),
		},
		"canvasViewPresenter": map[string]interface{}{
			"initialize": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterInitialize(this, args)
			}),
			"clientReady": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterClientReady(this, args)
			}),
			"fileSelected": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterFileSelected(this, args)
			}),
			"fileSaved": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterFileSaved(this, args)
			}),
			"useSystem": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterUseSystem(this, args)
			}),
			"addGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterAddGenerator(this, args)
			}),
			"deleteGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterDeleteGenerator(this, args)
			}),
			"updateGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterUpdateGenerator(this, args)
			}),
			"startGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterStartGenerator(this, args)
			}),
			"stopGenerator": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterStopGenerator(this, args)
			}),
			"startAllGenerators": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterStartAllGenerators(this, args)
			}),
			"stopAllGenerators": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterStopAllGenerators(this, args)
			}),
			"addMetric": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterAddMetric(this, args)
			}),
			"deleteMetric": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterDeleteMetric(this, args)
			}),
			"setParameter": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterSetParameter(this, args)
			}),
			"evaluateFlows": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterEvaluateFlows(this, args)
			}),
			"diagramComponentClicked": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterDiagramComponentClicked(this, args)
			}),
			"diagramComponentHovered": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.canvasViewPresenterDiagramComponentHovered(this, args)
			}),
		},
		"systemsService": map[string]interface{}{
			"listSystems": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.systemsServiceListSystems(this, args)
			}),
			"getSystem": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.systemsServiceGetSystem(this, args)
			}),
			"getSystemContent": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.systemsServiceGetSystemContent(this, args)
			}),
		},
	}
	js.Global().Set("sdl", js.ValueOf(sdl))

	fmt.Println("sdl WASM module loaded successfully")
}

// =============================================================================
// WASM API Functions - Generated Method Wrappers
// =============================================================================

// canvasServiceCreateCanvas handles the CreateCanvas method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceCreateCanvas(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.CreateCanvasRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.CreateCanvas(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceUpdateCanvas handles the UpdateCanvas method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceUpdateCanvas(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.UpdateCanvasRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.UpdateCanvas(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceListCanvases handles the ListCanvases method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceListCanvases(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListCanvasesRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.ListCanvases(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceGetCanvas handles the GetCanvas method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceGetCanvas(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetCanvasRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.GetCanvas(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceLoadFile handles the LoadFile method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceLoadFile(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.LoadFileRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.LoadFile(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceUseSystem handles the UseSystem method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceUseSystem(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.UseSystemRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.UseSystem(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceDeleteCanvas handles the DeleteCanvas method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceDeleteCanvas(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteCanvasRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.DeleteCanvas(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceResetCanvas handles the ResetCanvas method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceResetCanvas(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ResetCanvasRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.ResetCanvas(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceAddGenerator handles the AddGenerator method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceAddGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.AddGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.AddGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceStartAllGenerators handles the StartAllGenerators method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceStartAllGenerators(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StartAllGeneratorsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.StartAllGenerators(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceStopAllGenerators handles the StopAllGenerators method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceStopAllGenerators(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StopAllGeneratorsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.StopAllGenerators(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceListGenerators handles the ListGenerators method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceListGenerators(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListGeneratorsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.ListGenerators(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceGetGenerator handles the GetGenerator method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceGetGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.GetGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceUpdateGenerator handles the UpdateGenerator method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceUpdateGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.UpdateGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.UpdateGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceStopGenerator handles the StopGenerator method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceStopGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StopGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.StopGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceStartGenerator handles the StartGenerator method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceStartGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StartGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.StartGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceDeleteGenerator handles the DeleteGenerator method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceDeleteGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.DeleteGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceExecuteTrace handles the ExecuteTrace method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceExecuteTrace(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ExecuteTraceRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.ExecuteTrace(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceTraceAllPaths handles the TraceAllPaths method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceTraceAllPaths(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.TraceAllPathsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.TraceAllPaths(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceSetParameter handles the SetParameter method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceSetParameter(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.SetParameterRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.SetParameter(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceGetParameters handles the GetParameters method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceGetParameters(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetParametersRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.GetParameters(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceBatchSetParameters handles the BatchSetParameters method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceBatchSetParameters(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.BatchSetParametersRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.BatchSetParameters(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceEvaluateFlows handles the EvaluateFlows method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceEvaluateFlows(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.EvaluateFlowsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.EvaluateFlows(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceGetFlowState handles the GetFlowState method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceGetFlowState(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetFlowStateRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.GetFlowState(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceAddMetric handles the AddMetric method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceAddMetric(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.AddMetricRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.AddMetric(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceDeleteMetric handles the DeleteMetric method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceDeleteMetric(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteMetricRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.DeleteMetric(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceListMetrics handles the ListMetrics method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceListMetrics(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListMetricsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.ListMetrics(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceQueryMetrics handles the QueryMetrics method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceQueryMetrics(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.QueryMetricsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.QueryMetrics(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceStreamMetrics handles the StreamMetrics method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceStreamMetrics(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Server streaming method: expect request JSON and callback function
	if len(args) < 2 {
		return wasm.CreateJSResponse(false, "Request JSON and callback function required for streaming method", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	callback := args[1]
	if callback.Type() != js.TypeFunction {
		return wasm.CreateJSResponse(false, "Second argument must be a callback function", nil)
	}

	// Parse request
	req := &v1models.StreamMetricsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true,
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Start streaming in goroutine to avoid blocking
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		// Create a stream wrapper that implements StreamMetrics_ServerStream
		streamWrapper := &serverStreamWrapperStreamMetrics{
			ctx:      ctx,
			callback: callback,
		}

		// Call the server streaming method with the correct signature
		err := exports.CanvasService.StreamMetrics(req, streamWrapper)
		if err != nil {
			// Call callback with error and done=true
			callback.Invoke(js.Null(), err.Error(), true)
			return
		}

		// Signal completion
		callback.Invoke(js.Null(), js.Null(), true)
	}()

	// Return immediately for streaming methods
	return wasm.CreateJSResponse(true, "Server streaming started", nil)
}

// canvasServiceGetSystemDiagram handles the GetSystemDiagram method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceGetSystemDiagram(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetSystemDiagramRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.GetSystemDiagram(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasServiceGetUtilization handles the GetUtilization method for CanvasService
func (exports *Sdl_v1ServicesExports) canvasServiceGetUtilization(this js.Value, args []js.Value) any {
	if exports.CanvasService == nil {
		return wasm.CreateJSResponse(false, "CanvasService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetUtilizationRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasService.GetUtilization(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// singletonInitializerServiceInitializeSingleton handles the InitializeSingleton method for SingletonInitializerService
func (exports *Sdl_v1ServicesExports) singletonInitializerServiceInitializeSingleton(this js.Value, args []js.Value) any {
	if exports.SingletonInitializerService == nil {
		return wasm.CreateJSResponse(false, "SingletonInitializerService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.InitializeSingletonRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.SingletonInitializerService.InitializeSingleton(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterInitialize handles the Initialize method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterInitialize(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.InitializePresenterRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.Initialize(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterClientReady handles the ClientReady method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterClientReady(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ClientReadyRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.ClientReady(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterFileSelected handles the FileSelected method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterFileSelected(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.FileSelectedRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.FileSelected(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterFileSaved handles the FileSaved method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterFileSaved(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.FileSavedRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.FileSaved(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterUseSystem handles the UseSystem method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterUseSystem(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.UseSystemRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.UseSystem(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterAddGenerator handles the AddGenerator method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterAddGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.AddGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.AddGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterDeleteGenerator handles the DeleteGenerator method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterDeleteGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.DeleteGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterUpdateGenerator handles the UpdateGenerator method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterUpdateGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.UpdateGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.UpdateGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterStartGenerator handles the StartGenerator method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterStartGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StartGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.StartGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterStopGenerator handles the StopGenerator method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterStopGenerator(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StopGeneratorRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.StopGenerator(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterStartAllGenerators handles the StartAllGenerators method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterStartAllGenerators(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StartAllGeneratorsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.StartAllGenerators(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterStopAllGenerators handles the StopAllGenerators method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterStopAllGenerators(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.StopAllGeneratorsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.StopAllGenerators(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterAddMetric handles the AddMetric method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterAddMetric(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.AddMetricRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.AddMetric(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterDeleteMetric handles the DeleteMetric method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterDeleteMetric(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DeleteMetricRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.DeleteMetric(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterSetParameter handles the SetParameter method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterSetParameter(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.SetParameterRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.SetParameter(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterEvaluateFlows handles the EvaluateFlows method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterEvaluateFlows(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.EvaluateFlowsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.EvaluateFlows(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterDiagramComponentClicked handles the DiagramComponentClicked method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterDiagramComponentClicked(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DiagramComponentClickedRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.DiagramComponentClicked(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// canvasViewPresenterDiagramComponentHovered handles the DiagramComponentHovered method for CanvasViewPresenter
func (exports *Sdl_v1ServicesExports) canvasViewPresenterDiagramComponentHovered(this js.Value, args []js.Value) any {
	if exports.CanvasViewPresenter == nil {
		return wasm.CreateJSResponse(false, "CanvasViewPresenter not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.DiagramComponentHoveredRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.CanvasViewPresenter.DiagramComponentHovered(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// systemsServiceListSystems handles the ListSystems method for SystemsService
func (exports *Sdl_v1ServicesExports) systemsServiceListSystems(this js.Value, args []js.Value) any {
	if exports.SystemsService == nil {
		return wasm.CreateJSResponse(false, "SystemsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.ListSystemsRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.SystemsService.ListSystems(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// systemsServiceGetSystem handles the GetSystem method for SystemsService
func (exports *Sdl_v1ServicesExports) systemsServiceGetSystem(this js.Value, args []js.Value) any {
	if exports.SystemsService == nil {
		return wasm.CreateJSResponse(false, "SystemsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetSystemRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.SystemsService.GetSystem(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// systemsServiceGetSystemContent handles the GetSystemContent method for SystemsService
func (exports *Sdl_v1ServicesExports) systemsServiceGetSystemContent(this js.Value, args []js.Value) any {
	if exports.SystemsService == nil {
		return wasm.CreateJSResponse(false, "SystemsService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return wasm.CreateJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return wasm.CreateJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &v1models.GetSystemContentRequest{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.SystemsService.GetSystemContent(ctx, req)
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return wasm.CreateJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return wasm.CreateJSResponse(true, "Success", json.RawMessage(responseJSON))
}
