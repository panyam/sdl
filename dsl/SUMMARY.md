# SDL DSL Package Summary (`sdl/dsl`)

**Purpose:**

This package implements the execution engine for the System Design Language (DSL). It takes an Abstract Syntax Tree (AST) representing a system definition (components, instances, analysis targets) and evaluates it by orchestrating calls to the underlying `sdl/core` and `sdl/components` libraries. Its goal is to provide a higher-level, declarative interface for system performance modeling.

**Key Concepts & Components:**

1.  **Abstract Syntax Tree (AST) (`ast.go`):**
    *   Defines the Go structs (`Node`, `Expr`, `Stmt`, `ComponentDecl`, `SystemDecl`, `InstanceDecl`, `AnalyzeDecl`, `LiteralExpr`, `CallExpr`, `AndExpr`, `IfStmt`, `BlockStmt`, `ReturnStmt`, `distribute`, `delay`, etc.) that represent the parsed structure of the DSL code.
    *   The AST is generated by the `components/decl` package or (in the future) by a dedicated DSL parser.

2.  **Virtual Machine (VM) (`vm.go`, `eval_*.go`):**
    *   The core execution engine that walks the AST.
    *   Maintains an execution `stack` for intermediate results.
    *   Manages `Environment`s (`environment.go`) for scoping and storing variables, component instances, and function definitions.
    *   Implements `Eval(Node)` which dispatches to specific evaluation functions (`evalLiteral`, `evalAndExpr`, `evalIfStmt`, `evalCallExpr`, `evalDistribute`, etc.) based on the AST node type.
    *   **Implicit Outcome Model (V4):** Tracks two implicit distributions per variable/expression: `Outcomes[V]` (discrete value) and `Outcomes[Duration]` (latency).
    *   Handles sequential composition (`And`) by combining latency distributions and propagating value distributions.
    *   Handles conditional logic (`IfStmt`) by splitting both value and latency distributions based on the condition.
    *   Handles `distribute` blocks for probabilistic control flow, combining results from branches.
    *   Handles `delay` statements to explicitly add latency.
    *   Applies implicit reduction (`TrimToSize`, etc.) using `core` functions when outcome complexity exceeds `maxOutcomeLen`.

3.  **Environment (`environment.go`):**
    *   Simple lexical scoping mechanism using nested maps (`store`, `outer`).
    *   Stores component definitions (constructors), instances, and intermediate variable values (which are the implicit `Outcomes[V]` / `Outcomes[Duration]` pairs).

4.  **Reducer Registry (`vm.go`):**
    *   Used primarily by the VM's composition logic (`combineOutcomesAndReduce`) to find the correct function for combining `Outcomes[Duration]` distributions during sequential execution (`And`).
    *   Currently registered: `Duration + Duration`. Value combination is handled more directly by VM logic based on the discrete value set assumption.

5.  **Driver (`driver.go`):**
    *   Provides the top-level `RunDSL` function.
    *   Takes the root AST node (`SystemDecl`).
    *   Initializes the VM, registers built-in component constructors and internal functions.
    *   Processes the `SystemDecl`:
        *   Instantiates component instances defined in the system, storing them in the system's environment.
        *   Evaluates `AnalyzeDecl` blocks by calling `vm.Eval` on the target expression.
        *   Calculates standard metrics (`Availability`, `P99`, etc.) on the resulting outcome using `core` functions.
        *   Returns results wrapped in `AnalysisResultWrapper`.

6.  **Internal Functions (`driver.go`, `vm.go`):**
    *   Functions registered with the VM (e.g., `GetDiskReadProfile`, `ScaleLatency`, `CalculateBTreeHeight`) that are called by the AST generated by `decl` components. These functions often perform calculations or retrieve pre-defined profiles, returning `Outcomes` objects.

**Current Status:**

*   AST definition (`ast.go`) covers most planned language constructs.
*   VM (`vm.go`) structure, environment, stack, and reducer registry (for latency) are implemented.
*   Evaluation logic (`eval_*.go`) is implemented for: Literals, Identifiers, `AndExpr`, `CallExpr` (supporting Go method calls returning `Outcomes` or `ast.Node`, handling deterministic arguments), `InternalCallExpr`, `BlockStmt`, `AssignmentStmt`, `ReturnStmt`, `ExprStmt`, `IfStmt`, `RepeatExpr` (Sequential), `MemberAccessExpr` (specifically for `.Success` used in `If`).
*   **Migration to Model V4 (Implicit Outcomes + Discrete Values + Explicit Delay) is the current plan, but the VM implementation largely reflects the earlier Hybrid model or intermediate stages.** Significant refactoring of `eval*` functions (especially `And`, `If`, `Block`, `Call`) is needed to fully implement the dual-track (value + latency) implicit model.
*   The `distribute` and `delay` evaluators are **not yet implemented**.
*   The Driver (`RunDSL`) can instantiate components with literal parameters and run `analyze` blocks, producing metrics. Component instantiation needs refinement for non-literal params/dependencies.
*   A DSL Parser is **not yet implemented**.

**Next Steps:**

*   Refactor VM evaluation logic (`eval*`) to fully support the dual-track implicit outcome model (V4).
*   Implement `evalDistribute` and `evalDelay`.
*   Implement remaining expression evaluators (`ParallelExpr`, `FanoutExpr`, `FilterExpr`, `SwitchExpr`).
*   Refine driver logic (component instantiation, options, `expect` clauses).
*   Implement the DSL parser.
