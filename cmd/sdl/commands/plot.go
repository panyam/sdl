package commands

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/panyam/sdl/decl"
	"github.com/panyam/sdl/loader"
	"github.com/panyam/sdl/runtime"
	"github.com/panyam/sdl/viz"
	"github.com/spf13/cobra"
)

func plotCmd() *cobra.Command {
	plotCmd := &cobra.Command{
		Use:   "plot [<system_name> <instance_name> <method_name>]",
		Short: "Generates plots from simulation data or live runs.",
		Long: `Generates latency, count, and histogram plots.

This command can operate in two modes:

1. Live Run Mode:
   Executes a method on a component instance multiple times and plots latency percentiles.
   Example: sdl plot Twitter tls GetTimeline -f examples/twitter/services.sdl

2. From File Mode:
   Reads a JSON data file generated by 'sdl run' and plots data from it.
   This mode is more powerful and allows for plotting latency, counts, or histograms.
   - Latency Plot: --y-axis=latency
   - Count Plot:   --y-axis=count --group-by=result
   - Histogram:    --y-axis=histogram --metric=latency`,
		Run: func(cmd *cobra.Command, args []string) {
			fromFile, _ := cmd.Flags().GetString("from")
			outputFile, _ := cmd.Flags().GetString("output")
			title, _ := cmd.Flags().GetString("title")

			if fromFile != "" {
				yAxis, _ := cmd.Flags().GetString("y-axis")
				groupBy, _ := cmd.Flags().GetString("group-by")
				metric, _ := cmd.Flags().GetString("metric")
				plotFromFile(fromFile, outputFile, title, yAxis, groupBy, metric)
			} else {
				if len(args) != 3 {
					cmd.Help()
					fmt.Fprintln(os.Stderr, "\nError: live run mode requires <system_name>, <instance_name>, and <method_name> arguments.")
					os.Exit(1)
				}
				systemName, instanceName, methodName := args[0], args[1], args[2]
				plotFromLiveRun(systemName, instanceName, methodName, outputFile, title, cmd)
			}
		},
	}

	plotCmd.Flags().StringP("output", "o", "output.svg", "Output file path for the plot (e.g., plot.svg)")
	plotCmd.Flags().String("title", "", "Title for the plot. If empty, a default is generated.")
	plotCmd.Flags().String("from", "", "Path to a JSON results file (from 'sdl run --out'). If provided, live simulation is skipped.")
	plotCmd.Flags().String("y-axis", "latency", "Metric for the Y-axis ('latency', 'count', or 'histogram'). Only used with --from.")
	plotCmd.Flags().String("group-by", "result", "How to group data for 'count' plots ('result' or 'error'). Only used with --from.")
	plotCmd.Flags().String("metric", "latency", "The metric to use for a histogram plot ('latency'). Only used with --y-axis=histogram.")
	plotCmd.Flags().Int("numbatches", 100, "Number of batches to run (live mode only).")
	plotCmd.Flags().Int("numworkers", 50, "Number of parallel workers (live mode only).")
	plotCmd.Flags().Int("batchsize", 100, "Number of runs per batch (live mode only).")

	return plotCmd
}

func plotFromFile(fromFile, outputFile, title, yAxis, groupBy, metric string) {
	data, err := os.ReadFile(fromFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading file %s: %v\n", fromFile, err)
		os.Exit(1)
	}

	var results []RunResult
	if err := json.Unmarshal(data, &results); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing JSON from %s: %v\n", fromFile, err)
		os.Exit(1)
	}
	fmt.Printf("Successfully parsed %d results from %s.\n", len(results), fromFile)

	switch yAxis {
	case "latency":
		plotLatencyFromFile(results, outputFile, title)
	case "count":
		plotCountsFromFile(results, outputFile, title, groupBy)
	case "histogram":
		plotHistogramFromFile(results, outputFile, title, metric)
	default:
		fmt.Fprintf(os.Stderr, "Error: Invalid --y-axis value '%s'. Choose 'latency', 'count', or 'histogram'.\n", yAxis)
		os.Exit(1)
	}
}

func plotHistogramFromFile(results []RunResult, outputFile, title, metric string) {
	if len(results) == 0 {
		fmt.Println("No results to plot.")
		return
	}

	var values []float64
	for _, r := range results {
		if !r.IsError {
			switch metric {
			case "latency":
				values = append(values, r.Latency)
			default:
				fmt.Fprintf(os.Stderr, "Error: Invalid --metric value '%s' for histogram. Only 'latency' is supported.\n", metric)
				os.Exit(1)
			}
		}
	}

	if len(values) == 0 {
		fmt.Println("No successful runs to plot in histogram.")
		return
	}

	sort.Float64s(values)
	minVal, maxVal := values[0], values[len(values)-1]
	numBuckets := 20
	if len(values) < numBuckets {
		numBuckets = len(values)
	}
	if numBuckets == 0 {
		fmt.Println("No data to create histogram buckets.")
		return
	}

	bucketSize := (maxVal - minVal) / float64(numBuckets)
	buckets := make([]viz.DataPoint, numBuckets)
	for i := range buckets {
		bucketStart := minVal + float64(i)*bucketSize
		// bucketEnd := bucketStart + bucketSize
		buckets[i] = viz.DataPoint{
			X: int64(bucketStart + bucketSize/2), // Use midpoint for X
		}
	}

	for _, v := range values {
		bucketIndex := int((v - minVal) / bucketSize)
		if bucketIndex >= numBuckets {
			bucketIndex = numBuckets - 1
		}
		if bucketIndex < 0 {
			bucketIndex = 0
		}
		buckets[bucketIndex].Y++
	}

	series := []viz.DataSeries{
		{Name: "Distribution", Points: buckets},
	}

	if title == "" {
		title = fmt.Sprintf("Histogram of %s", strings.Title(metric))
	}

	fmt.Println("Generating histogram plot...")
	config := viz.DefaultPlotConfig()
	config.PlotType = viz.BarChart
	plotter := viz.NewSVGPlotter(config)

	svg, err := plotter.Generate(series, title, strings.Title(metric), "Frequency")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating plot: %v\n", err)
		os.Exit(1)
	}
	writeOutput(outputFile, svg)
}

func plotCountsFromFile(results []RunResult, outputFile, title, groupBy string) {
	if len(results) == 0 {
		fmt.Println("No results to plot.")
		return
	}

	buckets := make(map[string]map[int64]int)
	for _, r := range results {
		var category string
		switch groupBy {
		case "result":
			category = r.ResultValue
		case "error":
			if r.IsError {
				category = r.ErrorString
			} else {
				category = "Success"
			}
		default:
			fmt.Fprintf(os.Stderr, "Invalid --group-by value '%s'\n", groupBy)
			os.Exit(1)
		}

		if _, ok := buckets[category]; !ok {
			buckets[category] = make(map[int64]int)
		}
		bucketTime := (r.Timestamp / 1000) * 1000 // Floor to the second
		buckets[category][bucketTime]++
	}

	series := make([]viz.DataSeries, 0, len(buckets))
	for category, timeCounts := range buckets {
		points := make([]viz.DataPoint, 0, len(timeCounts))
		for ts, count := range timeCounts {
			points = append(points, viz.DataPoint{X: ts, Y: float64(count)})
		}
		sort.Slice(points, func(i, j int) bool { return points[i].X < points[j].X })
		series = append(series, viz.DataSeries{Name: category, Points: points})
	}
	sort.Slice(series, func(i, j int) bool { return series[i].Name < series[j].Name })

	if title == "" {
		title = fmt.Sprintf("Count of %s per Second", strings.Title(groupBy))
	}

	fmt.Println("Generating count plot...")
	plotter := viz.NewSVGPlotter(viz.DefaultPlotConfig())
	svg, err := plotter.Generate(series, title, "Time", "Count per Second")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating plot: %v\n", err)
		os.Exit(1)
	}
	writeOutput(outputFile, svg)
}

func plotLatencyFromFile(results []RunResult, outputFile, title string) {
	if len(results) == 0 {
		fmt.Println("No results to plot.")
		return
	}

	buckets := make(map[int64][]float64)
	for _, r := range results {
		if !r.IsError {
			bucketTime := (r.Timestamp / 1000) * 1000
			buckets[bucketTime] = append(buckets[bucketTime], r.Latency)
		}
	}

	avgVals, p50Vals, p90Vals, p99Vals := make([]viz.DataPoint, 0, len(buckets)), make([]viz.DataPoint, 0, len(buckets)), make([]viz.DataPoint, 0, len(buckets)), make([]viz.DataPoint, 0, len(buckets))
	sortedTimestamps := make([]int64, 0, len(buckets))
	for ts := range buckets {
		sortedTimestamps = append(sortedTimestamps, ts)
	}
	sort.Slice(sortedTimestamps, func(i, j int) bool { return sortedTimestamps[i] < sortedTimestamps[j] })

	for _, ts := range sortedTimestamps {
		latencies := buckets[ts]
		sort.Float64s(latencies)
		if len(latencies) > 0 {
			var total float64
			for _, lat := range latencies {
				total += lat
			}
			avgVals = append(avgVals, viz.DataPoint{X: ts, Y: total / float64(len(latencies))})
			p50Vals = append(p50Vals, viz.DataPoint{X: ts, Y: latencies[int(float64(len(latencies))*0.5)]})
			p90Vals = append(p90Vals, viz.DataPoint{X: ts, Y: latencies[int(float64(len(latencies))*0.9)]})
			p99Vals = append(p99Vals, viz.DataPoint{X: ts, Y: latencies[int(float64(len(latencies))*0.99)]})
		}
	}

	fmt.Println("Generating latency plot...")
	generateLatencyPlot(outputFile, title, avgVals, p50Vals, p90Vals, p99Vals)
}

func plotFromLiveRun(systemName, instanceName, methodName, outputFile, title string, cmd *cobra.Command) {
	numWorkers, _ := cmd.Flags().GetInt("numworkers")
	numBatches, _ := cmd.Flags().GetInt("numbatches")
	batchSize, _ := cmd.Flags().GetInt("batchsize")

	if dslFilePath == "" {
		fmt.Fprintln(os.Stderr, "Error: DSL file path must be specified with -f or --file for live runs.")
		os.Exit(1)
	}

	l := loader.NewLoader(nil, nil, 10)
	rt := runtime.NewRuntime(l)
	fi := rt.LoadFile(dslFilePath)
	system := fi.NewSystem(systemName)

	avgVals := make([]viz.DataPoint, numBatches)
	p50Vals := make([]viz.DataPoint, numBatches)
	p90Vals := make([]viz.DataPoint, numBatches)
	p99Vals := make([]viz.DataPoint, numBatches)
	now := time.Now()
	timeDelta := time.Second * 1

	fmt.Printf("Running live simulation for %s.%s.%s...\n", systemName, instanceName, methodName)

	runtime.RunCallInBatches(system, instanceName, methodName, numBatches, batchSize, numWorkers, func(batch int, batchVals []decl.Value) {
		if (batch+1)%10 == 0 || batch == numBatches-1 {
			log.Printf("... processed batch %d / %d", batch+1, numBatches)
		}
		sort.Slice(batchVals, func(i, j int) bool { return batchVals[i].Time < batchVals[j].Time })
		t := now.Add(time.Duration(batch) * timeDelta)
		timestamp := t.UnixMilli()

		if len(batchVals) > 0 {
			p50Vals[batch] = viz.DataPoint{X: timestamp, Y: batchVals[int(float64(len(batchVals))*0.5)].Time * 1000}
			p90Vals[batch] = viz.DataPoint{X: timestamp, Y: batchVals[int(float64(len(batchVals))*0.9)].Time * 1000}
			p99Vals[batch] = viz.DataPoint{X: timestamp, Y: batchVals[int(float64(len(batchVals))*0.99)].Time * 1000}
			var totalLatency float64
			for _, bv := range batchVals {
				totalLatency += bv.Time
			}
			avgVals[batch] = viz.DataPoint{X: timestamp, Y: (totalLatency / float64(len(batchVals))) * 1000}
		} else {
			// Ensure empty points are still created to keep arrays aligned
			p50Vals[batch] = viz.DataPoint{X: timestamp, Y: 0}
			p90Vals[batch] = viz.DataPoint{X: timestamp, Y: 0}
			p99Vals[batch] = viz.DataPoint{X: timestamp, Y: 0}
			avgVals[batch] = viz.DataPoint{X: timestamp, Y: 0}
		}
	})

	fmt.Println("Simulation finished. Generating latency plot...")
	generateLatencyPlot(outputFile, title, avgVals, p50Vals, p90Vals, p99Vals)
}

func generateLatencyPlot(outputFile, title string, avg, p50, p90, p99 []viz.DataPoint) {
	if title == "" {
		title = "API Latency"
	}
	series := []viz.DataSeries{
		{Name: "p50", Points: p50},
		{Name: "p90", Points: p90},
		{Name: "p99", Points: p99},
		{Name: "avg", Points: avg},
	}

	plotter := viz.NewSVGPlotter(viz.DefaultPlotConfig())
	svg, err := plotter.Generate(series, title, "Time", "Latency (ms)")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating plot: %v\n", err)
		os.Exit(1)
	}
	writeOutput(outputFile, svg)
}

func init() {
	AddCommand(plotCmd())
}
