package commands

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/panyam/sdl/decl"
	"github.com/panyam/sdl/loader"
	"github.com/panyam/sdl/runtime"
	"github.com/spf13/cobra"
)

func plotCmd() *cobra.Command {
	plotCmd := &cobra.Command{
		Use:   "plot [<system_name> <instance_name> <method_name>]",
		Short: "Generates plots from simulation data or live runs.",
		Long: `Generates latency and count plots.

This command can operate in two modes:

1. Live Run Mode:
   Executes a method on a component instance multiple times and plots latency percentiles.
   Example: sdl plot Twitter tls GetTimeline -f examples/twitter/services.sdl

2. From File Mode:
   Reads a JSON data file generated by 'sdl run' and plots data from it.
   This mode is more powerful and allows for plotting latency or counts of results.
   Example: sdl plot --from results.json --y-axis=count --group-by=result`,
		Run: func(cmd *cobra.Command, args []string) {
			fromFile, _ := cmd.Flags().GetString("from")
			outputFile, _ := cmd.Flags().GetString("output")
			title, _ := cmd.Flags().GetString("title")

			if fromFile != "" {
				yAxis, _ := cmd.Flags().GetString("y-axis")
				groupBy, _ := cmd.Flags().GetString("group-by")
				plotFromFile(fromFile, outputFile, title, yAxis, groupBy)
			} else {
				if len(args) != 3 {
					cmd.Help()
					fmt.Fprintln(os.Stderr, "\nError: live run mode requires <system_name>, <instance_name>, and <method_name> arguments.")
					os.Exit(1)
				}
				systemName, instanceName, methodName := args[0], args[1], args[2]
				plotFromLiveRun(systemName, instanceName, methodName, outputFile, title, cmd)
			}
		},
	}

	// General flags
	plotCmd.Flags().StringP("output", "o", "output.svg", "Output file path for the plot(s) (e.g., plot.svg)")
	plotCmd.Flags().String("title", "", "Title for the plot. If empty, a default is generated.")

	// File mode flags
	plotCmd.Flags().String("from", "", "Path to a JSON results file (from 'sdl run --out'). If provided, live simulation is skipped.")
	plotCmd.Flags().String("y-axis", "latency", "Metric for the Y-axis ('latency' or 'count'). Only used with --from.")
	plotCmd.Flags().String("group-by", "result", "How to group data for 'count' plots ('result' or 'error'). Only used with --from.")

	// Live run mode flags
	plotCmd.Flags().Int("numbatches", 100, "Number of batches to run (live mode only).")
	plotCmd.Flags().Int("numworkers", 50, "Number of parallel workers (live mode only).")
	plotCmd.Flags().Int("batchsize", 100, "Number of runs per batch (live mode only).")

	return plotCmd
}

func plotFromFile(fromFile, outputFile, title, yAxis, groupBy string) {
	fmt.Printf("Reading results from %s...\n", fromFile)
	data, err := os.ReadFile(fromFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading file %s: %v\n", fromFile, err)
		os.Exit(1)
	}

	var results []RunResult
	if err := json.Unmarshal(data, &results); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing JSON from %s: %v\n", fromFile, err)
		os.Exit(1)
	}
	fmt.Printf("Successfully parsed %d results.\n", len(results))

	switch yAxis {
	case "latency":
		plotLatencyFromFile(results, outputFile, title)
	case "count":
		plotCountsFromFile(results, outputFile, title, groupBy)
	default:
		fmt.Fprintf(os.Stderr, "Error: Invalid --y-axis value '%s'. Choose 'latency' or 'count'.\n", yAxis)
		os.Exit(1)
	}
}

func plotCountsFromFile(results []RunResult, outputFile, title, groupBy string) {
	if len(results) == 0 {
		fmt.Println("No results to plot.")
		return
	}

	// 1. Aggregate counts per category per time bucket
	// map[category][timestamp] -> count
	buckets := make(map[string]map[int64]int)
	for _, r := range results {
		var category string
		switch groupBy {
		case "result":
			category = r.ResultValue
		case "error":
			if r.IsError {
				category = r.ErrorString
			} else {
				category = "Success"
			}
		default:
			fmt.Fprintf(os.Stderr, "Invalid --group-by value '%s'\n", groupBy)
			os.Exit(1)
		}

		if _, ok := buckets[category]; !ok {
			buckets[category] = make(map[int64]int)
		}
		bucketTime := (r.Timestamp / 1000) * 1000 // Floor to the second
		buckets[category][bucketTime]++
	}

	// 2. Convert aggregated data to DataSeries
	var plotData MultiSeriesPlotData
	plotData.Series = make([]DataSeries, 0, len(buckets))

	for category, timeCounts := range buckets {
		series := DataSeries{Name: category, Points: make([]DataPoint, 0, len(timeCounts))}
		for ts, count := range timeCounts {
			series.Points = append(series.Points, DataPoint{X: ts, Y: float64(count)})
		}
		sort.Slice(series.Points, func(i, j int) bool { return series.Points[i].X < series.Points[j].X })
		plotData.Series = append(plotData.Series, series)
	}
	sort.Slice(plotData.Series, func(i, j int) bool { return plotData.Series[i].Name < plotData.Series[j].Name })

	// 3. Generate the plot
	if title == "" {
		title = fmt.Sprintf("Count of %s per Second", strings.Title(groupBy))
	}
	plotData.Metadata = PlotMetadata{
		Title:  title,
		XLabel: "Time",
		YLabel: "Count per Second",
	}

	fmt.Println("Generating count plot...")
	plotMulti(outputFile, plotData)
}

func plotLatencyFromFile(results []RunResult, outputFile, title string) {
	if len(results) == 0 {
		fmt.Println("No results to plot.")
		return
	}

	buckets := make(map[int64][]float64)
	for _, r := range results {
		if !r.IsError {
			bucketTime := (r.Timestamp / 1000) * 1000
			buckets[bucketTime] = append(buckets[bucketTime], r.Latency)
		}
	}

	avgVals, p50Vals, p90Vals, p99Vals := make([]DataPoint, 0, len(buckets)), make([]DataPoint, 0, len(buckets)), make([]DataPoint, 0, len(buckets)), make([]DataPoint, 0, len(buckets))
	sortedTimestamps := make([]int64, 0, len(buckets))
	for ts := range buckets {
		sortedTimestamps = append(sortedTimestamps, ts)
	}
	sort.Slice(sortedTimestamps, func(i, j int) bool { return sortedTimestamps[i] < sortedTimestamps[j] })

	for _, ts := range sortedTimestamps {
		latencies := buckets[ts]
		sort.Float64s(latencies)
		if len(latencies) > 0 {
			var total float64
			for _, lat := range latencies {
				total += lat
			}
			avgVals = append(avgVals, DataPoint{X: ts, Y: total / float64(len(latencies))})
			p50Vals = append(p50Vals, DataPoint{X: ts, Y: latencies[int(float64(len(latencies))*0.5)]})
			p90Vals = append(p90Vals, DataPoint{X: ts, Y: latencies[int(float64(len(latencies))*0.9)]})
			p99Vals = append(p99Vals, DataPoint{X: ts, Y: latencies[int(float64(len(latencies))*0.99)]})
		}
	}

	fmt.Println("Generating latency plots...")
	generateLatencyPlots(outputFile, title, avgVals, p50Vals, p90Vals, p99Vals)
}

func plotFromLiveRun(systemName, instanceName, methodName, outputFile, title string, cmd *cobra.Command) {
	numWorkers, _ := cmd.Flags().GetInt("numworkers")
	numBatches, _ := cmd.Flags().GetInt("numbatches")
	batchSize, _ := cmd.Flags().GetInt("batchsize")

	if dslFilePath == "" {
		fmt.Fprintln(os.Stderr, "Error: DSL file path must be specified with -f or --file for live runs.")
		os.Exit(1)
	}

	l := loader.NewLoader(nil, nil, 10)
	rt := runtime.NewRuntime(l)
	fi := rt.LoadFile(dslFilePath)
	system := fi.NewSystem(systemName)

	avgVals := make([]DataPoint, numBatches)
	p50Vals := make([]DataPoint, numBatches)
	p90Vals := make([]DataPoint, numBatches)
	p99Vals := make([]DataPoint, numBatches)
	now := time.Now()
	timeDelta := time.Second * 1

	fmt.Printf("Running live simulation for %s.%s.%s...\n", systemName, instanceName, methodName)

	runtime.RunCallInBatches(system, instanceName, methodName, numBatches, batchSize, numWorkers, func(batch int, batchVals []decl.Value) {
		if (batch+1)%10 == 0 || batch == numBatches-1 {
			log.Printf("... processed batch %d / %d", batch+1, numBatches)
		}
		sort.Slice(batchVals, func(i, j int) bool { return batchVals[i].Time < batchVals[j].Time })
		t := now.Add(time.Duration(batch) * timeDelta)

		if len(batchVals) > 0 {
			p50Vals[batch].Y = batchVals[int(float64(len(batchVals))*0.5)].Time * 1000
			p90Vals[batch].Y = batchVals[int(float64(len(batchVals))*0.9)].Time * 1000
			p99Vals[batch].Y = batchVals[int(float64(len(batchVals))*0.99)].Time * 1000
			var totalLatency float64
			for _, bv := range batchVals {
				totalLatency += bv.Time
			}
			avgVals[batch].Y = (totalLatency / float64(len(batchVals))) * 1000
		}
		avgVals[batch].X, p50Vals[batch].X, p90Vals[batch].X, p99Vals[batch].X = t.UnixMilli(), t.UnixMilli(), t.UnixMilli(), t.UnixMilli()
	})

	fmt.Println("Simulation finished. Generating plots...")
	generateLatencyPlots(outputFile, title, avgVals, p50Vals, p90Vals, p99Vals)
}

func generateLatencyPlots(outputFile, title string, avg, p50, p90, p99 []DataPoint) {
	pctFileName := func(prefix string) string {
		if strings.HasSuffix(outputFile, ".svg") {
			return strings.Replace(outputFile, ".svg", fmt.Sprintf("_%s.svg", prefix), 1)
		}
		return fmt.Sprintf("%s_%s.svg", outputFile, prefix)
	}
	plot(pctFileName("avg"), avg, "Time", "Latency Avg (ms)", title+" - Avg API Latency")
	plot(pctFileName("p50"), p50, "Time", "Latency p50 (ms)", title+" - p50 API Latency")
	plot(pctFileName("p90"), p90, "Time", "Latency p90 (ms)", title+" - p90 API Latency")
	plot(pctFileName("p99"), p99, "Time", "Latency p99 (ms)", title+" - p99 API Latency")
}

func init() {
	AddCommand(plotCmd())
}
